---
layout: post
title: 클린 아키텍처 - 웹은 세부사항이다.
categories: [Study, Book]
tags: [clean architecture, architecture]
---

# Table of Contents

1.  [끝없이 반복하는 추](#org063be1d)
2.  [요약](#org9f96185)
3.  [결론](#org4b64cd7)

1960년도 이래로 우리 업계는 일련의 반복되는 진동을 겪어왔고, 현재 웹은 그저 이러한 진동의 맨 끝에 있을 뿐이다.
이 진동은 모든 연산 능력을 중앙 서버에 두는 방식과 모든 연산 능력을 단말에 두는 방식 사이에서 끊임없이 움직여 왔다.


<a id="org063be1d"></a>

# 끝없이 반복하는 추

반복되는 진동이 웹으로부터 시작되었다고 보는 일은 옳지 않다.
웹이 있기 전에는 클라이언트-서버 아키텍처가 있었다.
그 전에는 다수의 멍청한 단말기가 연결되는 중앙집중식 미니컴퓨터가 있었다.

그리고 그 이야기는 계속된다.
앞으로도 우리는 연산 능력을 어디에 둘지 알 수 없을 것이다.
연산능력을 중앙에 집중하는 방식과 분산하는 방식 사이에서 우리는 끊임없이 움직인다.

아키텍트로서 우리는 멀리 내다봐야 한다.
이 진동은 그저 핵심 업무 규칙의 중심에서 밀어내고 싶은 단기적인 문제일 뿐이다.

다양한 앱과 소프트웨어의 GUI가 변경되기도 하고 다시 원복되기도 한다.
이로부터 애플리케이션을 보호하기 위해 무슨 일을 해야 할까?

업무 규칙을 UI로부터 분리해야 한다.


<a id="org9f96185"></a>

# 요약

GUI =  세부사항
웹 = GUI
따라서 웹은 세부사항이다.
이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다.

UI와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재한다.
업무 로직은 다수의 유스케이스로 구성되며, 각 유스케이스는 사용자를 대신해서 일부 함수를 수행하는 것으로 볼 수 있다.

완전한 입력 데이터와 그에 따른 출력 데이터는 데이터 구조로 만들어서 유스케이스를 실행하는 처리 과정을 입력 값과 출력 값으로 사용할 수 있다.
이 방식을 따르면 각 유스케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다고 생각할 수 있다.


<a id="org4b64cd7"></a>

# 결론

이러한 종류의 추상화는 만들기 쉽지 않고, 제대로 만들려면 수차례를 반복 과정을 거처야 할 것이다.
하지만 가능하다.
그리고 GUI를 변경하고 싶어하는 마케터가 많기 때문에 이러한 추상화가 꼭 필요할 때가 많다고 주장하기는 어렵지 않다.

