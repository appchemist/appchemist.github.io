<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="DDIA - 저장소와 검색" /><meta property="og:locale" content="en" /><meta name="description" content="Table of Contents" /><meta property="og:description" content="Table of Contents" /><link rel="canonical" href="https://appchemist.github.io/posts/DDIA-CH3/" /><meta property="og:url" content="https://appchemist.github.io/posts/DDIA-CH3/" /><meta property="og:site_name" content="Appchemist" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-13T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="DDIA - 저장소와 검색" /><meta name="twitter:site" content="@appchemist" /><meta name="google-site-verification" content="ayKW7N1F1Lf9GFGDgfNENpw486FaeJYvFrGByBGAGEI" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-13T00:00:00+09:00","datePublished":"2022-05-13T00:00:00+09:00","description":"Table of Contents","headline":"DDIA - 저장소와 검색","mainEntityOfPage":{"@type":"WebPage","@id":"https://appchemist.github.io/posts/DDIA-CH3/"},"url":"https://appchemist.github.io/posts/DDIA-CH3/"}</script><title>DDIA - 저장소와 검색 | Appchemist</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Appchemist"><meta name="application-name" content="Appchemist"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://avatars.githubusercontent.com/u/1546031?v=4 " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Appchemist</a></div><div class="site-subtitle font-italic">Software Developer, Want to being a Developer likes alchemist.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/appchemist" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/appchemist" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['appchemist','hotmail.co.kr'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>DDIA - 저장소와 검색</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>DDIA - 저장소와 검색</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/appchemist">appchemist</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1652367600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-05-13 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7186 words"> <em>39 min</em> read</span></div></div></div><div class="post-content"><h1 id="table-of-contents">Table of Contents</h1><ol><li><a href="#org638a95f">들어가기</a><li><a href="#org8ecc7f3">데이터베이스를 강력하게 만드는 데이터 구조</a><ol><li><a href="#org890b131">해시 색인</a><li><a href="#org03a0bcf">SS테이블과 LSM 트리</a><ol><li><a href="#org0a4273d">SS테이블 생성과 유지</a><li><a href="#org3d03c70">성능 최적화</a><li><a href="#orgf0c4e71">모아보기</a></ol><li><a href="#orgd346cdc">B 트리</a><ol><li><a href="#orgbfca903">최적화</a></ol><li><a href="#orga388854">B 트리와 LSM 트리 비교</a><ol><li><a href="#org4b96b90">LSM 트리의 장점</a></ol><li><a href="#org43c41bb">기타 색인 구조</a><ol><li><a href="#orga8a40de">색인에 값 저장하기</a><li><a href="#org05b0faa">다중 컬럼 색인</a><li><a href="#orgdc2129f">전문 검색과 퍼지 색인</a><li><a href="#orgba3c373">모든 것을 메모리에 보관</a></ol></ol><li><a href="#org4877aa6">트랜잭션 처리나 분석?</a><ol><li><a href="#org14a03f3">데이터 웨어하우징</a><li><a href="#org182ba1e">분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마</a></ol><li><a href="#orgc6f6b95">칼럼 지향 저장소</a><ol><li><a href="#org9e7e260">칼럼 압축</a><ol><li><a href="#org0a1566e">메모리 대역폭과 벡터화 처리</a></ol><li><a href="#org6bbdfcf">칼럼 저장소의 순서 정렬</a><ol><li><a href="#orgd1c93df">다양한 순서 정렬</a></ol><li><a href="#org0b63ab4">칼럼 지향 저장소에 쓰기</a><li><a href="#orgbcfd158">집계: 데이터 큐브와 구체화 뷰</a></ol></ol><p><a id="org638a95f"></a></p><h1 id="들어가기">들어가기</h1><p>해당 챕터에서는 <strong>데이터베이스가 데이터를 저장하는 방법</strong>, <strong>데이터를 다시 찾는 방법</strong> 에 대해서 설명한다.</p><p>애플리케이션 개발자가 해당 내용을 알아야 하는 이유</p><ul><li>애플리케이션에 적합한 엔진을 선택하는 작업이 필요<li>특정 작업부하 유형에서 저장소 엔진의 성능을 조정<br /> 저장소 엔진이 내부에서 수행되는 작업에 대한 대략적인 개념을 이해할 필요</ul><p><a id="org8ecc7f3"></a></p><h1 id="데이터베이스를-강력하게-만드는-데이터-구조">데이터베이스를 강력하게 만드는 데이터 구조</h1><p>많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그를 사용</p><ul><li>일반적으로 파일 추가 작업은 매우 효율적</ul><p>반면 로그(append-only)에 많은 레코드가 있고, 로그에서 단순한 조회 처리는 성능이 매우 좋지 않다.(검색 비용 O(n))<br /> 이렇듯 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조가 필요한데, 이것이 바로 <strong>색인</strong> 이다.</p><p>색인</p><ul><li>일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것<br /> 이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는 데 도움을 준다.<li>기본 데이터에서 파생된 추가적인 구조<br /> 추가적인 구조의 유지보수는 특히 쓰기 과정에서 오버헤드가 발생 -&gt; 쓰기 속도를 느리게 만듬</ul><p><a id="org890b131"></a></p><h2 id="해시-색인"><span class="mr-2">해시 색인</span><a href="#해시-색인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>매우 일반적이고 더욱 복잡한 색인을 위한 구성 요소로 유용하다.</p><p>단순히 파일에 추가하는 방식으로 데이터 저장소를 구성한다고 가정해보자.<br /> 그러면 가장 간단한 색인 전략은 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략이다.</p><p><img data-src="/assets/img/저장소와_검색/2022-05-09_21-53-42_index_in_memory_hashmap.jpeg" alt="img" data-proofer-ignore><br /> <strong>키-값 쌍의 로그, 인메모리 해시 맵으로 색인</strong></p><p><strong>파일에 항상 추가만 한다면 결국 디스크 공간이 부족해진다. 이 상황은 어떻게 피할 수 있을까?</strong><br /> 좋은 해결책으로 <strong>특정 크기의 세그먼트(segment)</strong> 로 로그를 나누는 방식이 있다.</p><ul><li>특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 이후 쓰기를 수행<li>세그먼트 파일들에 대해 컴팩션을 수행<br /> 컴팩션은 각 키의 최신 갱신 값만 유지하는 것을 의미<li>고정된 세그먼트의 병합과 컴팩션은 백그라운드 스레드에서 수행할 수 있다.<li>컴팩션 동안 이전 세그먼트 파일을 사용해 읽기와 쓰기 요청을 처리<li><p>병합 이후, 새로 병합한 세그먼트로 전환(이전 세그먼트 파일은 삭제)</p><p><img data-src="/assets/img/저장소와_검색/2022-05-09_22-11-48_compaction_and_merge.jpeg" alt="img" data-proofer-ignore></p></ul><p><strong>컴팩션과 병합을 동시에 수행</strong></p><p>조회 처리 과정</p><ol><li>최신 세그먼트 해시 맵을 확인<li>1에서 키가 없다면 두 번째 최신 세그먼트 등을 확인</ol><p><strong>추가 전용 설계의 장점</strong></p><ul><li>추가와 세그먼트 병합은 순차 쓰기 작업이므로 보통 무작위 쓰기보다 훨씬 빠르다.<li>세그먼트 파일이 추가 전용 또는 불변이면 동시성과 고장 복구 측면에서 훨씬 간단하다.<li>오래된 세그먼트 병합은 조각화되는 데이터 파일 문제를 피할 수 있다.</ul><p><strong>해시 테이블 색인의 제한 사항</strong></p><ul><li>메모리에 저장해야 하므로 키가 너무 많으면 문제<li>비효율적인 범위 질의</ul><p><a id="org03a0bcf"></a></p><h2 id="ss테이블과-lsm-트리"><span class="mr-2">SS테이블과 LSM 트리</span><a href="#ss테이블과-lsm-트리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>지금까지 이야기한 세그먼트 파일의 형식에서 간단한 변경 사항 한 가지를 적용해보자.<br /> <strong>키-값 쌍을 키로 정렬하는 것</strong> 이다.</p><p>이것을 정렬된 문자열 테이블(Sorted String Table) 또는 짧게 SS테이블이라 부른다.<br /> 또한 각 키는 각 병합된 세그먼트 파일 내에 한 번만 있어야 한다.</p><p>SS테이블은 해시 색인을 가진 로그 세그먼트와 비교해 몇 가지 장점 가진다.</p><ol><li>세그먼트 병합은 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적<ul><li>각 파일의 첫 번째 키를 확인, 가장 낮은 키를 새 병합 세그먼트 파일로 복사를 반복<li><p>여러 세그먼트가 동일한 키를 포함한 경우, 가장 최근 세그먼트의 값을 유지하고 오래된 세그먼트의 값은 버린다.</p><p><img data-src="/assets/img/저장소와_검색/2022-05-09_22-56-40_merging_SSTable_segments.jpeg" alt="img" data-proofer-ignore><br /> <strong>SS테이블 세그먼트 병합, 각 키의 최신 값만 유지</strong></p></ul><li><p>특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없다.</p><p><img data-src="/assets/img/저장소와_검색/2022-05-09_23-00-55_SSTable_with_in_memory_index.jpeg" alt="img" data-proofer-ignore><br /> <strong>일부 키에 대한 오프셋만 유지한 인메모리 색인(희소 색인)을 가진 SS테이블</strong></p><li>레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축<ul><li>읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문<li>디스크 공간 절약<li>I/O 대역폭 사용 절약</ul></ol><p><a id="org0a4273d"></a></p><h3 id="ss테이블-생성과-유지"><span class="mr-2">SS테이블 생성과 유지</span><a href="#ss테이블-생성과-유지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>쓰기 요청은 인메모리 균형 트리 데이터 구조(red-black tree, AVL tree 등)에 추가<br /> memtable이라고도 함<li>멤테이블이 임계값보다 커지면 SS테이블 파일로 디스크에 기록<br /> 해당 SS 테이블은 가장 최신 세그먼트<br /> 디스크에 기록하는 동안 쓰기는 신규 멤테이블에 기록<li>읽기 요청은 멤테이블, 최신 세그먼트, 다음 세그먼트 … 순으로 진행<li>가끔 세그먼트들을 병합, 컴팩션 과정을 수행<br /> 백그라운드에서 수행</ul><p>장애를 대비하기 위해 별도의 로그를 디스크에 작성한다.<br /> 이 로그는 장애 후, 멤테이블을 복원하기 위해서만 사용하기에 정렬되지 않아도 된다.<br /> 멤테이블이 SS테이블로 기록되면 해당 로그는 지우고 새로 작성할 수 있다.</p><p><a id="org3d03c70"></a></p><h3 id="성능-최적화"><span class="mr-2">성능 최적화</span><a href="#성능-최적화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있다.<br /> 해당 경우를 최적화하기 위해 저장소 엔진은 보통 블룸 필터(Bloom filter)를 추가적으로 사용한다.</p><p>SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략은 다양하다.<br /> 일반적으로 2가지가 존재한다.</p><ul><li>크기 계층(size-tiered)<br /> 상대적으로 최신의 작은 SS테이블을 상대적으로 오래된 큰 SS테이블에 연이어 병합<li>레벨 컴팩션(leveled compaction)<br /> 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동<br /> 그래서 컴팩션을 점직적으로 진행해 디스크 공간을 덜 사용</ul><p><a id="orgf0c4e71"></a></p><h3 id="모아보기"><span class="mr-2">모아보기</span><a href="#모아보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>지금까지 이야기 한 내용의 색인 구조는 로그 구조화 병합 트리(Log-Structured Merge-Tree)라고 불린다.<br /> 그리고 LSM 트리의 구조를 보면 아래와 같다.<br /> SS테이블은 LSM 저장소 엔진의 한 구성 요소이다.</p><p>이 개념은 데이터셋이 가능한 메모리보다 훨씬 더 크더라도 효과적이다.<br /> 데이터가 정렬된 순서로 저장돼 범위 질의를 효율적으로 수행할 수 있다.<br /> 디스크 쓰기는 순차적이기에 매우 높은 쓰기 처리량도 보장한다.</p><p><img data-src="/assets/img/저장소와_검색/lsm_2022-05-11_09-01-33.png" alt="img" data-proofer-ignore><br /> <strong>출처 : <a href="http://kflu.github.io/2018/02/09/2018-02-09-lsm-tree">http://kflu.github.io/2018/02/09/2018-02-09-lsm-tree</a></strong></p><p><a id="orgd346cdc"></a></p><h2 id="b-트리"><span class="mr-2">B 트리</span><a href="#b-트리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>특징</p><ul><li>가장 널리 사용되는 색인 구조이다.<li>정렬된 키-값 쌍을 유지<br /> 키-값 검색과 범위 질의에 효율적이다.<li>고정 크기 블록 혹은 페이지 단위로 읽기 또는 쓰기<li>리프 페이지는 각 키의 값 혹은 실제 값을 포함한 페이지의 참조를 포함<li>동시성 제어는 보통 래치(latch)로 트리의 데이터 구조를 보호<li>WAL 또는 Redo log 데이터 구조 관리</ul><p>데이터 베이스 크래시 상황을 대비해 디스크 상에 쓰기 전 로그(write-ahead log, WAL) 또는 재실행 로그(redo log) 데이터 구조를 관리<br /> 쓰기 전 로그는 트리 페이지에 변경된 내용을 적용하기 전 모든 B 트리의 변경 사항을 기록하는 추가 전용 파일이다.<br /> 이 로그는 복구 시에 일관성 있는 상태로 B 트리를 다시 복원하는 데 사용한다.</p><p><a id="orgbfca903"></a></p><h3 id="최적화"><span class="mr-2">최적화</span><a href="#최적화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>WAL 대신 일부 데이터베이스는 쓰기 시 복사 방지(copy-on-write scheme)를 사용<li>키를 축약해 공간을 절약<br /> 트리 내부 페이지에서 키가 범위 사이의 경계 역할을 할수 있을 정도<li>리프 페이지를 디스크 상에 연속된 순서로 배치하려고 시도<br /> 하지만 트리가 커지면 순서를 유지하기가 어려움<li>트리에 포인터를 추가<br /> 예를 들어 각 리프 페이지에 양쪽 형제 페이지에 대한 포인터<li>트랙탈 트리</ul><p><a id="orga388854"></a></p><h2 id="b-트리와-lsm-트리-비교"><span class="mr-2">B 트리와 LSM 트리 비교</span><a href="#b-트리와-lsm-트리-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>LSM 트리는 보통 쓰기가 빠르지만 B 트리는 보통 읽기가 빠르다.<br /> LSM 트리가 보통 읽기가 느린 이유는 각 컴팩션 단계에 있는 여러 가지 데이터 구조와 SS 테이블을 확인해야 하기 때문이다.</p><p><a id="org4b96b90"></a></p><h3 id="lsm-트리의-장점"><span class="mr-2">LSM 트리의 장점</span><a href="#lsm-트리의-장점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>B 트리의 장점</p><ul><li>로그 구조화 저장소 엔진보다 예측이 쉬운 성능<li>각 키가 색인의 한 곳에만 정확히 존재<li>강력한 트랜잭션 시맨틱을 제공하는 데이터베이스에 매력적<li>많은 작업 부하에 지속적으로 좋은 성능을 제공</ul><p>B 트리 단점</p><ul><li>B 트리 색인은 모든 데이터 조각을 최소 2번 기록<br /> 쓰기 전 로그, 트리 페이지에 최소 1번 기록해야 하기 때문(쓰기 증폭)<li>페이지 내 몇 바이트만 바뀌어도 전체 페이지를 기록해야 하는 오버헤드 발생<li>파편화로 인해 사용하지 않는 디스크 공간 일부 낭비</ul><p>LSM 트리의 장점</p><ul><li>B 트리 대비 높은 쓰기 처리량<br /> 상대적으로 낮은 쓰기 증폭<br /> 컴팩션된 SS 테이블을 파일에 순차적 쓰기<li>B 트리 대비 높은 압축률<br /> 컴팩션 및 머지 프로세스를 통해 주기적으로 파편화 제거</ul><p>LSM 트리 단점</p><ul><li>SS 테이블의 반복된 컴팩션과 병합으로 여러 번 데이터를 다시 기록(쓰기 증폭)<li>컴팩션 과정이 때로는 진행 중인 읽기와 쓰기 성능에 영향<br /> 디스크가 가진 자원의 한계로 인해 발생<br /> 이로 인해서 상위 백분위 질의의 응답 시간이 때때로 꽤 길다.<li>데이터베이스가 커질수록 컴팩션을 위해 더 많은 디스크 대역폭이 필요<li>컴팩션이 유입 쓰기 속도를 못 따라갈 수 있다.<br /> 디스크 상에 병합되지 않은 세그먼트 수가 디스크 공간이 부족할 때까지 증가할 수 있다.<br /> 병합되지 않은 세그먼트 수가 늘어나 읽기 속도가 느려진다.<br /> 컴팩션 설정에 주의가 필요<li>여러 세그먼트에 같은 키의 다중 복사본이 존재할 수 있다.</ul><p><a id="org43c41bb"></a></p><h2 id="기타-색인-구조"><span class="mr-2">기타 색인 구조</span><a href="#기타-색인-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>기본키(primary key) 색인</strong></p><ul><li>키-값 색인의 대표적인 예<li>대상 데이터(로우/문서/정점)를 키로 고유하게 식별 및 참조</ul><p><strong>보조 색인(secondary index)</strong></p><ul><li>보통 조인을 효율적으로 수행하는 데 결정적인 역할<li>키가 유일하지 않음</ul><p>보조 색인에서 키가 고유하지 않은 문제를 해결하는 방안(B 트리 &amp; 로그 구조화 색인 모두 사용 가능)</p><ul><li>색인의 각 값에 일치하는 로우 식별자 목록을 만드는 방법(전문 색인에서 포스팅 목록과 같음)<li>로우 식별자를 추가해 각 키를 고유하게 만드는 방법</ul><p><a id="orga8a40de"></a></p><h3 id="색인에-값-저장하기"><span class="mr-2">색인에 값 저장하기</span><a href="#색인에-값-저장하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>색인에서 값</p><ul><li>실제 로우(문서, 정점)<li>힙 파일을 가리키는 참조</ul><p>힙 파일 : 로우가 실제로 저장된 파일, 특정 순서 없이 데이터를 저장<br /> 힙 파일 접근은 일반적인 방식, 여러 보조 색인이 존재할 때 데이터 중복을 피할 수 있기 때문이다.</p><p>힙 파일 접근 방식</p><ul><li>키를 변경하지 않고 값을 갱신할 때 꽤 효율적<li>새로운 값이 이전 값 보다 많은 공간을 필요로 하지 않으면 레코드를 제자리에 덮어쓸 수 있다.<li>새로운 값이 많은 공간을 필요로 한다면 새로운 곳으로 위치를 이동<ul><li>모든 색인이 레코드의 새로운 힙 위치로 갱신<li>이전 힙 위치에 전방향 포인터 기록</ul></ul><p><strong>클러스터드 색인(clustered index)</strong></p><ul><li>색인 안에 색인된 로우를 저장<br /> 색인에서 힙 파일로 다시 이동하는 일은 읽기 성능에 불이익이 많기 때문<li>MySQL의 InnoDB에서 테이블의 기본키가 언제나 클러스터드 색인<li>MySQL의 InnoDB에서 보조 색인은 기본키를 참조</ul><p><strong>커버링 색인(covering index)</strong></p><ul><li>포괄열이 있는 색인(index with included column)으로도 불림<li>클러스터드 색인과 비클러스터드 색인 사이의 절충안<li>색인 안에 테이블의 컬럼 일부를 저장</ul><p>모든 종류의 데이터 복제와 마찬가지로 클러스터드 색인과 커버링 색인은 읽기 성능을 높일 수 있다.</p><p>하지만 추가적인 저장소가 필요하고 쓰기 오버헤드가 발생한다.<br /> 애플리케이션 단에서 복제로 인한 불일치를 파악할 수 없기 때문에 데이터베이스는 트랜잭션 보장을 강화하기 위해 별도의 노력이 필요하다.</p><p><a id="org05b0faa"></a></p><h3 id="다중-컬럼-색인"><span class="mr-2">다중 컬럼 색인</span><a href="#다중-컬럼-색인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>지금까지 이야기한 색인은 하나의 키만 값에 대응한다.<br /> 그래서 다중 컬럼에 동시에 질의를 해야 한다면 충분하지 않다.</p><p><strong>결합 색인(concatenated index)</strong></p><ul><li>다중 컬럼 색인의 가장 일반적인 유형<li>하나의 컬럼에 다른 컬럼을 추가하는 방식으로 하나의 키에 여러 필드를 단순히 결합</ul><p><strong>다차원 색인</strong></p><ul><li>조금 더 일반적인 방법<li>지리 공간 데이터에 중요하게 사용되지만 여기에 국한되지 않는다.<li>k-d 트리, 사분 트리, R 트리 등</ul><p>B 트리와 LSM 트리 색인에서도 지리 공간을 처리하는 한 가지 방법으로 공간 채움 곡선(space-filling curve)을 이용해 단일 숫자로 변환한 다음 색인에 사용하는 것이 있다.</p><p><a id="orgdc2129f"></a></p><h3 id="전문-검색과-퍼지-색인"><span class="mr-2">전문 검색과 퍼지 색인</span><a href="#전문-검색과-퍼지-색인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>지금까지 설명한 색인들은 키의 정확한 값이나 정렬된 키의 값의 범위를 질의할 수 있다고 가정한다.<br /> 그래서 유사한 키에 대해서 검색을 할 수 없다.<br /> 이처럼 애매모호한(fuzzy) 질의에는 다른 기술이 필요하다.</p><p>루씬은 용어 사전을 위해 SS 테이블 같은 구조를 사용한다.<br /> 인메모리 색인은 키를 찾는 데 필요한 정렬 파일의 오프셋을 질의에 알려주는 데 사용한다.<br /> 루씬의 인메모리 색인은 여러 키 내 문자에 대한 유한 상태 오토마톤(finite state automaton)으로 트라이(<a href="https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9D%BC%EC%9D%B4_(%EC%BB%B4%ED%93%A8%ED%8C%85)">trie</a>)와 유사하다.<br /> 이 오토마톤은 레벤슈타인 오토마톤(levenshtein automaton)으로 변환할 수 있다.<br /> <a href="https://juggernaut.tistory.com/entry/레벤슈타인-오토마타Levenshtein-Automata">레벤슈타인 오토마톤</a>은 특정 편집 거리 내에서 효율적인 단어 검색을 제공한다.</p><p>자세한 내용은 관련해서 찾아보자.</p><p><a id="orgba3c373"></a></p><h3 id="모든-것을-메모리에-보관"><span class="mr-2">모든 것을 메모리에 보관</span><a href="#모든-것을-메모리에-보관" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>지금까지 설명한 데이터 구조는 모두 디스크 한계에 대한 해결책이다.<br /> 디스크는 메인 메모리와 비교해 다루기 어렵지만, 디스크는 지속성과 가격면에서 장점이 있다.</p><p>하지만 램이 점점 저렴해져서 기가바이트당 가격 논쟁도 약해지고 여러 장비 간 분산해서 보관할 수도 있다.<br /> 이런 이유로 인메모리 데이터베이스가 개발됐다.</p><p>멤캐시드 같은 일부 인메모리 키-값 저장소는 장비가 재시작되면 데이터 손실을 허용하는 캐시 용도로만 사용된다.<br /> 하지만 다른 인메모리 데이터베이스는 지속성을 목표로 한다.</p><p>지속성을 달성하는 방법</p><ul><li>특수 하드웨어 사용(배터리 전원 공급 RAM 등)<li>디스크에 변경 사항 로그 기록<li>디스크에 주기적 스냅샷<li>다른 장비에 인메모리 상태를 복제</ul><p>하지만 디스크 기반 저장소 엔진도 충분한 메모리를 가진 경우에 OS의 페이지 캐시, 버퍼 캐시를 통해서 디스크에서 읽을 필요가 없다.<br /> 오히려 인메모리 데이터 구조를 디스크에 저장하기 위한 형태로 부호화하는 오버헤드를 피할 수 있어 더 빠를 수도 있다.</p><p><strong>디스크 기반 색인으로 구현하기 어려운 데이터 모델을 제공</strong><br /> 메모리에 모든 데이터를 유지하기 때문에 레디스의 우선순위 큐와 셋 등과 같이 다양한 구조를 구현하기가 비교적 간단하다.</p><p><strong>안티 캐싱(anti-caching) 접근 방식</strong><br /> LRU 알고리즘과 같이 가장 최근에 사용하지 않은 데이터를 메모리에서 디스크로 적제하는 방식도 있다.<br /> 하지만 여전히 전체 색인이 메모리에 있어야 한다.</p><p><a id="org4877aa6"></a></p><h1 id="트랜잭션-처리나-분석">트랜잭션 처리나 분석?</h1><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="org-left" /><col class="org-left" /><col class="org-left" /><thead><tr><th scope="col" class="org-left">특성<th scope="col" class="org-left">OLTP<th scope="col" class="org-left">OLAP<tbody><tr><td class="org-left">주요 읽기 패턴<td class="org-left">적은 수의 레코드, 키 기준 조회<td class="org-left">레코드에 대한 집계<tr><td class="org-left">주요 쓰기 패턴<td class="org-left">임의 접근, 사용자 입력을 낮은 지연 시간으로 기록<td class="org-left">Bulk import(ETL) 또는 이벤트 스트림<tr><td class="org-left">주요 사용처<td class="org-left">애플리케이션을 통한 최종 사용자/소비자<td class="org-left">의사결정 지원을 위한 내부 분석가<tr><td class="org-left">데이터 표현<td class="org-left">데이터의 최신 상태<td class="org-left">시간이 지나며 일어난 이벤트 이력<tr><td class="org-left">데이터셋 크기<td class="org-left">GB - TB<td class="org-left">TB - PB</table><p>과거 OLTP 시스템을 분석 목적으로 사용하지 않고 분석을 수행하기 위한 개별 데이터베이스를 데이터 웨어하우스(data warehouse)라고 불렀다.</p><p><a id="org14a03f3"></a></p><h2 id="데이터-웨어하우징"><span class="mr-2">데이터 웨어하우징</span><a href="#데이터-웨어하우징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>OLTP 시스템은 대개 사업 운영에 대단히 중요하기 때문에 일반적으로 높은 가용성과 낮은 지연 시간의 트랜잭션 처리를 기대한다.<br /> 반대로 데이터 웨어하우스는 분석가들이 OLTP 작업에 영향을 주지 않고 마음껏 질의할 수 있는 개별 데이터베이스다.</p><p>데이터는 OLTP 데이터베이스에서 추출(extract)하고 분석 친화적인 스키마로 변환(transform)하고 깨끗하게 정리한 다음 데이터 웨어하우스에 적재(load)한다.<br /> 데이터웨어하우스로 데이터를 가져오는 이 과정을 ETL(Extract-Transform-Load)이라 한다.</p><p>이 형태의 장점은 분석 접근 패턴에 맞게 최적화할 수 있다는 것이다.</p><p><a id="org182ba1e"></a></p><h2 id="분석용-스키마-별-모양-스키마와-눈꽃송이-모양-스키마"><span class="mr-2">분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마</span><a href="#분석용-스키마-별-모양-스키마와-눈꽃송이-모양-스키마" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>분석용 스키마 특징</strong></p><ul><li>사용하는 데이터 모델의 종류가 많지 않음<li>대부분 별 모양 스키마(star schema)로 알려진 정형화된 방식 사용<br /> 또는 차원 모델링(dimentional modeling)이라고도 불림<li>보통 테이블의 속성(컬럼)이 매우 많음</ul><p><strong>별 모양 스키마 특징</strong></p><ul><li>스키마 중심에 사실 테이블(fact table)이 존재<ul><li>각 로우는 특정 시각에 발생한 이벤트<li>보통 개별 이벤트를 저장<br /> 분석의 유연성 극대화 목적<br /> 이로 인해서 사실 테이블이 매우 커질 수 있음<li>사실 테이블의 다른 컬럼은 차원 테이블(dimension table)인 다른 테이블을 가리키는 외래 키 참조</ul><li>차원은 이벤트 속성인 누가, 언제, 어디서, 무엇을, 어떻게, 왜를 나타냄<ul><li>차원은 차원 테이블의 로우</ul><li>눈꽃송이 모양 스키마 대비 작업이 쉬워서 보통 분석가들이 더 선호</ul><p><img data-src="/assets/img/저장소와_검색/2022-05-12_16-48-15_Star_Schema.jpeg" alt="img" data-proofer-ignore><br /> <strong>별 모양 스키마 예제</strong></p><p><strong>눈꽃송이 모양 스키마 특징</strong></p><ul><li>별 모양 스키마의 변경<li>차원이 하위 차원으로 더 세분화<li>별 모양 스키마 보다 더 정규화<li>별 모양 스키마 대비 작업이 더 어려움</ul><p><a id="orgc6f6b95"></a></p><h1 id="칼럼-지향-저장소">칼럼 지향 저장소</h1><p>사실 테이블(fact table)은 컬럼이 보통 100개 이상이지만 질의는 한 번에 소수의 칼럼만 접근하며 다른 컬럼은 무시한다.</p><p>이때 100개의 칼럼 중 5개의 칼럼을 사용한 조건에 부합한 로우를 찾는다고 하자<br /> <strong>로우 지향</strong> 방식의 경우, 조건을 처리하기 위해서 색인을 사용하겠지만 부분적으로 색인이 존재하지 않을 수 있다.<br /> 그러면 모든 로우를 메모리로 적재해 필요한 조건을 충족하지 않은 로우를 필터링해야 한다.<br /> 이 작업은 오랜 시간이 걸릴 수 있다.</p><p>위와 같은 경우 컬럼 지향 저장소의 필요성이 부각될 수 있다.</p><p><strong>칼럼 지향 저장소 특징</strong></p><ul><li>모든 값을 하나의 로우에 함께 저장하지 않는다. 대신 각 칼럼별로 모든 값을 함께 저장한다.<li>각 칼럼 파일에 포함된 로우가 모두 같은 순서인 점에 의존</ul><p><img data-src="/assets/img/저장소와_검색/2022-05-12_17-06-05_Columnar_Storage_Layout_Example.jpeg" alt="img" data-proofer-ignore><br /> <strong>사실 테이블을 컬럼 단위로 저장</strong></p><p><a id="org9e7e260"></a></p><h2 id="칼럼-압축"><span class="mr-2">칼럼 압축</span><a href="#칼럼-압축" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>칼럼 지향 저장소는 대개 압축에 적합한데, 데이터를 압축하면 디스크 처리 요청을 더 줄일 수 있다.</p><p>칼럼의 데이터에 따라 다양한 압축 기법을 사용할 수 있다.<br /> 그 중 한 가지로 데이터 웨어하우스에서 특히 효과적인 <strong>비트맵 부호화(bitmap encoding)</strong> 이 있다.</p><p><img data-src="/assets/img/저장소와_검색/2022-05-12_17-39-26_column_value_encoding.jpeg" alt="img" data-proofer-ignore><br /> <strong>비트맵 부호화 &amp; 런랭스 부호화 예제</strong></p><p><a id="org0a1566e"></a></p><h3 id="메모리-대역폭과-벡터화-처리"><span class="mr-2">메모리 대역폭과 벡터화 처리</span><a href="#메모리-대역폭과-벡터화-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>수백만 로우를 스캔해야 하는 데이터 웨어하우스 질의는 디스크로부터 메모리로 데이터를 가져오는 대역폭이 큰 병목이다.<br /> 또한 CPU 주기를 효율적으로 사용하도록 신경 써야 한다.</p><p>칼럼 저장소 배치는 CPU 주기를 효율적으로 사용하기에 적합하다.<br /> 칼럼 압축을 사용하면 같은 양의 L1 캐시에 컬럼의 더 많은 로우를 저장할 수 있다.<br /> AND와 OR 연산자는 압축된 칼럼 데이터 덩어리를 바로 연산할 수 있게 설계할 수 있다.<br /> 이런 기법을 <strong>벡터화 처리(vectorized processing)</strong> 라고 한다.</p><p><a id="org6bbdfcf"></a></p><h2 id="칼럼-저장소의-순서-정렬"><span class="mr-2">칼럼 저장소의 순서 정렬</span><a href="#칼럼-저장소의-순서-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>칼럼 저장소는 삽입된 순서로 저장하는 방식이 가장 쉽지만, 순서가 반드시 중요한 것은 아니다.<br /> SS테이블에서 했던 것처럼 순서를 도입해 이를 색인 메커니즘으로 사용할 수 있다.</p><p>장점</p><ul><li>질의 최적화기는 모든 로우를 스캔하기보다 범위 질의에 포함되는 로우만 스캔 가능<li>칼럼 압축에 도움</ul><p>순서 지정은 여러개를 지정할 수 있지만 압축 효과는 첫 번째 정렬 키에서 가장 효과적이다.</p><p><a id="orgd1c93df"></a></p><h3 id="다양한-순서-정렬"><span class="mr-2">다양한 순서 정렬</span><a href="#다양한-순서-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>상업용 데이터 웨어하우스인 버티가에서 채택<br /> 데이터를 잃지 않기 위해 데이터를 여러 장비에 복제해 두는 작업이 필요하다.<br /> <strong>복제 데이터를 서로 다른 방식으로 정렬</strong> 해서 저장하고 질의를 처리할 때 <strong>질의 패턴에 가장 적합한 버전</strong> 을 사용할 수 있다.</p><p><a id="org0b63ab4"></a></p><h2 id="칼럼-지향-저장소에-쓰기"><span class="mr-2">칼럼 지향 저장소에 쓰기</span><a href="#칼럼-지향-저장소에-쓰기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>칼럼 지향 저장소, 압축, 정렬은 모두 읽기 질의를 더 빠르게 하지만 쓰기를 어렵게 한다는 단점이 존재<br /> 정렬된 테이블의 중간에 있는 로우에 삽입을 해야 하면 모든 칼럼 파일을 재작성해야 한다.</p><p>LSM 트리에서 이런 문제에 좋은 해결책있고 버티카가 채택한 방식이다.<br /> 모든 쓰기는 먼저 인메모리 저장소(WOS)에서 정렬된 구조에 추가해 디스크(ROS)에 쓸 준비를 한다.<br /> 충분한 인메모리 저장소 데이터가 모이면 디스크에 추가한다.(Moveout)<br /> 이렇게 모인 디스크의 데이터는 병합 하고 새로운 파일에 기록 한다.(Mergeout)</p><p><a href="https://www.vertica.com/blog/understanding-ros-and-wos-a-hybrid-data-storage-modelba-p233206/">Vertica의 ROS와 WOS 참고</a><br /> <a href="https://www.vertica.com/blog/write-optimized-storage-wos-deprecation-what-you-need-to-know/">Vertica의 WOS Deprecation 참고</a></p><p><a id="orgbcfd158"></a></p><h2 id="집계-데이터-큐브와-구체화-뷰"><span class="mr-2">집계: 데이터 큐브와 구체화 뷰</span><a href="#집계-데이터-큐브와-구체화-뷰" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>데이터 웨어하우스 질의는 보통 SQL의 COUNT, SUM, AVG, MIN, MAX 같은 집계 함수를 포함한다.</p><p>이렇게 자주 사용되는 집계 함수를 캐시를 하기 위해 <strong>구체화 뷰(materialized view)</strong> 라는 방법을 사용한다.<br /> 구체화 뷰는 디스크에 기록된 질의 결과의 <strong>실제 복사본</strong> 이다.</p><p>복사본이기에 원본 데이터를 변경하면 구체화 뷰를 갱신해야 한다.<br /> 이런 갱신 비용이 비싸기 때문에 OLTP 데이터베이스에서는 자주 사용하지 않는다.<br /> 데이터 웨어하우스는 읽기 비중이 크기 때문에 구체화 뷰를 사용하는 전략은 합리적이다.</p><p>여기서 이야기할 데이터 큐브(data cube) 또는 OLAP 큐브라고 알려진 구체화 뷰는 일반화된 구체화 뷰의 특별 사례다.</p><p><img data-src="/assets/img/저장소와_검색/2022-05-12_20-56-02_IMG_86EE6C49A544-1.jpeg" alt="img" data-proofer-ignore><br /> <strong>합으로 데이터를 집계한 2차원 데이터 큐브</strong></p><p>예제는 2차원이지만 일반적으로 2차원 이상이다.</p><p>구체화 데이터 큐브</p><ul><li>장점은 특정 질의를 미리 계산했기 때문에 해당 질의를 수행할 때 매우 빠름<li>단점은 원시 데이터에 질의하는 것과 동일한 유연성이 없다는 점</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/study/'>Study</a>, <a href='/categories/book/'>Book</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/data/" class="post-tag no-text-decoration" >Data</a> <a href="/tags/applicationn/" class="post-tag no-text-decoration" >Applicationn</a> <a href="/tags/system/" class="post-tag no-text-decoration" >System</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=DDIA - 저장소와 검색 - Appchemist&amp;url=https://appchemist.github.io/posts/DDIA-CH3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=DDIA - 저장소와 검색 - Appchemist&amp;u=https://appchemist.github.io/posts/DDIA-CH3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://appchemist.github.io/posts/DDIA-CH3/&amp;text=DDIA - 저장소와 검색 - Appchemist" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/DDIA-CH6/">DDIA - 파티셔닝</a><li><a href="/posts/DDIA-CH4/">DDIA - 부호화와_발전</a><li><a href="/posts/clean_architecture_ch20/">클린 아키텍처 - 업무 규칙</a><li><a href="/posts/clean_architecture_ch17/">클린 아키텍처 - 경계 선 긋기</a><li><a href="/posts/DDIA-CH1/">DDIA - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/DDIA-CH1/"><div class="card-body"> <em class="timeago small" data-ts="1651158000" > 2022-04-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DDIA - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</h3><div class="text-muted small"><p> Table of Contents 데이터 시스템에 대한 생각 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사 신뢰성 하드웨어 결함 소프트웨어 오류 인적 오류 확장성 부...</p></div></div></a></div><div class="card"> <a href="/posts/DDIA-CH2/"><div class="card-body"> <em class="timeago small" data-ts="1651762800" > 2022-05-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DDIA - 데이터 모델과 질의 언어</h3><div class="text-muted small"><p> Table of Contents 들어가기 관계형 모델과 문서 모델 객체 관계형 불일치 다대일과 다대다 관계 문서 데이터베이스는 역사를 반복하고 있나? 네트워크 모델 관계형 모델 문서 데이터베이스와의 비교 ...</p></div></div></a></div><div class="card"> <a href="/posts/DDIA-CH4/"><div class="card-body"> <em class="timeago small" data-ts="1652972400" > 2022-05-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DDIA - 부호화와_발전</h3><div class="text-muted small"><p> Table of Contents 데이터 부호화 형식 언어별 형식 JSON과 XML 그리고 이진 변경 이진 부호화 스리프트와 프로토콜 버퍼 스리프트 프로토콜 버퍼 필드 태그와...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/DDIA-CH2/" class="btn btn-outline-primary" prompt="Older"><p>DDIA - 데이터 모델과 질의 언어</p></a> <a href="/posts/DDIA-CH4/" class="btn btn-outline-primary" prompt="Newer"><p>DDIA - 부호화와_발전</p></a></div><script src="https://utteranc.es/client.js" repo="appchemist/appchemist.github.io" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/appchemist">appchemist</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-KEPDM82EY9"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KEPDM82EY9'); }); </script>
