<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Functors: Function Objects in C++" /><meta property="og:locale" content="en" /><meta name="description" content="C와 C++ 모두 function pointer를 지원한다. function pointer는 특정 명령을 수행하는 함수를 전달할 수 있는 방법 중 하나이다." /><meta property="og:description" content="C와 C++ 모두 function pointer를 지원한다. function pointer는 특정 명령을 수행하는 함수를 전달할 수 있는 방법 중 하나이다." /><link rel="canonical" href="https://appchemist.github.io/posts/functors-function-objects-c/" /><meta property="og:url" content="https://appchemist.github.io/posts/functors-function-objects-c/" /><meta property="og:site_name" content="Appchemist" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-06-20T11:18:23+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Functors: Function Objects in C++" /><meta name="twitter:site" content="@appchemist" /><meta name="google-site-verification" content="ayKW7N1F1Lf9GFGDgfNENpw486FaeJYvFrGByBGAGEI" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-06-20T11:18:23+09:00","datePublished":"2016-06-20T11:18:23+09:00","description":"C와 C++ 모두 function pointer를 지원한다. function pointer는 특정 명령을 수행하는 함수를 전달할 수 있는 방법 중 하나이다.","headline":"Functors: Function Objects in C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://appchemist.github.io/posts/functors-function-objects-c/"},"url":"https://appchemist.github.io/posts/functors-function-objects-c/"}</script><title>Functors: Function Objects in C++ | Appchemist</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Appchemist"><meta name="application-name" content="Appchemist"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://avatars.githubusercontent.com/u/1546031?v=4 " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Appchemist</a></div><div class="site-subtitle font-italic">Software Developer, Want to being a Developer likes alchemist.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/appchemist" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/appchemist" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['appchemist','hotmail.co.kr'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Functors: Function Objects in C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Functors: Function Objects in C++</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/appchemist">appchemist</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1466389103" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2016-06-20 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1583 words"> <em>8 min</em> read</span></div></div></div><div class="post-content"><p>C와 C++ 모두 function pointer를 지원한다. function pointer는 특정 명령을 수행하는 함수를 전달할 수 있는 방법 중 하나이다.</p><p>하지만, function pointer는 매우 제한적인데, function pointer는 컴파일 시점에 해당 함수가 정의되어 있어야 한다. 그럼 왜 이것 때문에 function pointer가 제한적이라고 하는 것일까?</p><p>수신함을 보는 메일 프로그램을 작성하는 예를 들어보자. 사용자가 다양한 필드(to, from, date 등)를 이용해서 수신함을 정렬을 할 수 있도록 하고 싶다. 메시지를 비교하는 정렬 루틴을 메시지 비교를 하는 function pointer를 사용하고자 할것이다. 메일의 필드만 달리 비교하는 함수를 만들수도 있지만, 이는 하드 코딩된 필드만 정렬할 수 있을 것이다. 결국 정렬 루틴에서 사용할 다양한 함수들을 만들게 된다.</p><p>비교 함수에 어떤 필드를 비교할지 알려주는 제 3의 인자를 전달 하고 싶을 것이다. 그러나 이렇게 하기 위해서는 제 3의 인자를 아는 정렬 루틴을 만들어야 한다. 그러면 제 3의 인자를 comparator에 전달 할수 없으므로 STL과 같은 generic routine을 사용할 수 없다. 대신, 함수 내부에서 어떤 필드를 정렬할지 아는 함수가 필요 하다.</p><p>위와 같은 문제를 해결하기 위해서 C++에서 function object(functors)를 사용할 수 있다. functor는 function과 function pointer와 같이 다룰 수 있는 객체이다. 아래와 같은 코드를 작성할 수 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">myFunctorClass</span> <span class="n">functor</span><span class="p">;</span>
<span class="err"> </span><span class="n">functor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></table></code></div></div><p>C++은 operator()(function call)를 오버로드할 수 있으므로 위의 코드는 작동한다. function call operator는 여러개의 인자와 다양한 타입을 받을 수 있고 어떤 것이든 결과 값으로 전달 할 수 있다. 이것은 operator를 오버로드할 수 있으므로써 생기는 유연성이다. 이후 해당 글에서 객체의 operator()를 호출할 때 객체를 호출했다고 이야기 하겠다.</p><p>오버로딩한 operator()가 좋지만, functor의 진면목은 functor의 life cycle이 function 보다 더 유연하다는 점이다. functor의 생성자에 추후에 operator()에서 사용할 정보들 삽입할 수 있다.</p><p>다음 예제는 integer 인자를 받는 생성자를 가진 functor class를 생성한다. 해당 클래스의 객체가 호출되면 저장된 값과 인자 값을 더한 결과를 반환한다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myFunctorClass</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">myFunctorClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_x</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">myFunctorClassTest</span><span class="p">,</span> <span class="n">TestSimpleAdding</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">myFunctorClass</span> <span class="n">addFive</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">addFive</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>결론적으로 생성자에 인자를 넘겨주는면, 이후 해당 인수를 사용하는 함수와 같은 동작을 한다.</p><h3 id="sorting-mail"><span class="mr-2">Sorting Mail</span><a href="#sorting-mail" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>이제 정렬 functor를 구현하기 위해서 코드를 어떻게 작성하면 될지 생각해보자.</p><p>두개의 인자를 받는 operator()가 필요하고 정렬하고자 하는 필드 정보를 저장하는 생성자가 필요하다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getHeader</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">header_name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MessageSorter</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MessageSorter</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">field</span><span class="p">)</span> <span class="o">:</span> <span class="n">_field</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">getHeader</span><span class="p">(</span><span class="n">_field</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">getHeader</span><span class="p">(</span><span class="n">_field</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_field</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>이제 메시지 vector가 있다면, 우리는 STL sort 함수를 사용해서 정렬을 할 수 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">TEST</span><span class="p">(</span><span class="n">MessageSorterTest</span><span class="p">,</span> <span class="n">TestMessageSorter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">messages</span><span class="p">;</span>
    <span class="c1">// read in messages</span>
    <span class="n">MessageSorter</span> <span class="n">comparator</span><span class="p">(</span><span class="s">"to"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">messages</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">messages</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comparator</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="functors-compared-with-function-pointers"><span class="mr-2">Functors Compared with Function Pointers</span><a href="#functors-compared-with-function-pointers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Function Pointer를 인자로 받는 함수는 Functor를 인자로 넘길수 없다. 심지어 Functor가 Function Pointer와 동일한 인자와 결과값을 가진다고 해도 넘길수 없다.</p><p>이와 비슷하게 Functor를 인자로 받는 함수는 Function pointer를 인자로 넘길수 없다.</p><h3 id="functors-function-pointers-and-templates"><span class="mr-2">Functors, Function Pointers and Templates</span><a href="#functors-function-pointers-and-templates" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Function Pointer와 Fuctor를 동일한 함수에 인자로 넘기고자 한다면, 템플릿을 사용해야 한다. 템플릿 함수는 Functor와 Function Pointer를 적절한 타입으로 추론하고 Functor와 Function Pointer를 동일한 방식으로 사용한다. 둘 다 함수 호출과 같은 형태를 취한다. 그래서 해당 함수는 컴파일이 무사히 된다.</p><p>예를 들어 보면 아래와 같은 함수가 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">find_matching_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pred</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret_vec</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">itr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">ret_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">itr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>위의 함수를 Functor와 Function Pointers를 모두 사용하도록 두번째 인자를 템플릿화하도록 수정했다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">FuncType</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">find_matching_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">FuncType</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret_vec</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">itr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">ret_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">itr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="functor-vs-virtual-functions"><span class="mr-2">Functor vs. Virtual Functions</span><a href="#functor-vs-virtual-functions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Functor와 Virtual Function은 매우 관련있다고 한다. 이 둘은 어떤 코드가 알고리즘을 어떻게 선택하도록 할지에 대한 문제를 해결 한다.</p><p>자, 상상해보자. doMath라는 함수가 있다. 이 함수는 3개의 인자를 받는다. 2개의 인자는 integer이고, 나머지 하나는 어떤 연산을 수행하는 루틴이다. Functor로 작성한 예는 아래와 같다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">FuncType</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">doMath</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">FuncType</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>다른 방법으로 computeResult 메소드를 가진 인터페이스 클래스를 생성할 수 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MathComputer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">computeResult</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">doMath</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">MathComputer</span><span class="o">*</span> <span class="n">p_computer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p_computer</span><span class="o">-&gt;</span><span class="n">computeResult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>위의 두 예제는 virtual function과 functor 모두 특정 알고리즘이 실행되는 시점에 동적으로 선택을 할 수 있다. 두 개의 주요한 차이점은 virtual function은 템플릿 함수를 사용하더라도 function pointer를 인자로 받을 수 없다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >c++</a> <a href="/tags/function-pointer/" class="post-tag no-text-decoration" >function pointer</a> <a href="/tags/functor/" class="post-tag no-text-decoration" >functor</a> <a href="/tags/template/" class="post-tag no-text-decoration" >template</a> <a href="/tags/virtual-function/" class="post-tag no-text-decoration" >virtual function</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Functors: Function Objects in C++ - Appchemist&amp;url=https://appchemist.github.io/posts/functors-function-objects-c/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Functors: Function Objects in C++ - Appchemist&amp;u=https://appchemist.github.io/posts/functors-function-objects-c/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://appchemist.github.io/posts/functors-function-objects-c/&amp;text=Functors: Function Objects in C++ - Appchemist" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/DDIA-CH6/">DDIA - 파티셔닝</a><li><a href="/posts/DDIA-CH4/">DDIA - 부호화와_발전</a><li><a href="/posts/clean_architecture_ch20/">클린 아키텍처 - 업무 규칙</a><li><a href="/posts/clean_architecture_ch17/">클린 아키텍처 - 경계 선 긋기</a><li><a href="/posts/DDIA-CH1/">DDIA - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/efficient-ceab080ec8381-ed95a8ec8898/"><div class="card-body"> <em class="timeago small" data-ts="1468331680" > 2016-07-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>EFFICIENT C++_가상 함수</h3><div class="text-muted small"><p> 동적 바인딩 덕분에 프로그래머는 형식 확인을 컴파일러에게 맡기게 되었고 많이 편해졌다. 반대로 동적 바인딩은 성능에 부정적인 영향을 끼칠 수 있다. 가상 함수 기법 만약 가상 함수를 사용하고 싶지 않다면, 직접 형식 확인 코드를 작성하여 동적 바인딩을 흉내를 낼수있다. 다음은 동물원 동물을 클래스로 표현한 것이다. 1 2 3 4 5 6 7 8 c...</p></div></div></a></div><div class="card"> <a href="/posts/efficient-ceba19ceab985eab3bc-eab480eba0/"><div class="card-body"> <em class="timeago small" data-ts="1468183508" > 2016-07-11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Efficient C++_로깅과 관련된 성능 이야기</h3><div class="text-muted small"><p> 소프트웨어를 유지보수를 하다보면 로깅이 매우 중요하다. 로깅을 통해서 문제 상황 추적 및 프로그램의 실행 흐름을 파악하는데 많은 도움이 된다. 이런 로깅과 관련된 코드는 성능과 관련된 여러가지 문제들을 만나기 쉽다. 로깅과 관련된 성능 최적화의 극단적인 방법은 추적 호출을 #ifdef 블록 안에 내장하여 성능 부하를 제거하는 것이다. 1 2 3 4...</p></div></div></a></div><div class="card"> <a href="/posts/867/"><div class="card-body"> <em class="timeago small" data-ts="1468284994" > 2016-07-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>EFFICIENT C++_생성자와 소멸자</h3><div class="text-muted small"><p> 상속 이상적으로는 생성자와 소멸자는 오버헤드를 가지지 않아야 한다. 생성자와 소멸자는 오직 필수적인 초기화와 정리 작업을 수행하며, 일반적인 컴파일러는 이것들을 인라인 함수로 만들것이다. 하지만, 상속과 합성 구현은 가끔 혹은 절대 사용되지 않는 연산을 수행하기도 한다. 상속과 합성 구현은 코드의 재사용을 위한 기술이다. 즉, 코드의 재사용과 성능과...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/ebb894eba19ceab7b8ec9790-code-highlighting/" class="btn btn-outline-primary" prompt="Older"><p>블로그에 Code Highlighting 적용하기</p></a> <a href="/posts/efficient-ceba19ceab985eab3bc-eab480eba0/" class="btn btn-outline-primary" prompt="Newer"><p>Efficient C++_로깅과 관련된 성능 이야기</p></a></div><script src="https://utteranc.es/client.js" repo="appchemist/appchemist.github.io" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/appchemist">appchemist</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-KEPDM82EY9"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KEPDM82EY9'); }); </script>
