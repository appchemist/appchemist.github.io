<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="EFFICIENT C++_임시 객체" /><meta property="og:locale" content="en" /><meta name="description" content="임시 객체 생성은 성능적으로 작은 영향을 주는 부분은 아니다. 즉, 임시 객체의 기원, 그것의 비용 그리고 임시 객체를 제거할 수 있는 방법을 알지 않고서는 효율적인 코드를 작성하기 힘들다." /><meta property="og:description" content="임시 객체 생성은 성능적으로 작은 영향을 주는 부분은 아니다. 즉, 임시 객체의 기원, 그것의 비용 그리고 임시 객체를 제거할 수 있는 방법을 알지 않고서는 효율적인 코드를 작성하기 힘들다." /><link rel="canonical" href="https://appchemist.github.io/posts/efficient-cec9e84ec8b9c-eab09decb2b4/" /><meta property="og:url" content="https://appchemist.github.io/posts/efficient-cec9e84ec8b9c-eab09decb2b4/" /><meta property="og:site_name" content="Appchemist" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-07-16T08:52:44+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="EFFICIENT C++_임시 객체" /><meta name="twitter:site" content="@appchemist" /><meta name="google-site-verification" content="ayKW7N1F1Lf9GFGDgfNENpw486FaeJYvFrGByBGAGEI" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-07-16T08:52:44+09:00","datePublished":"2016-07-16T08:52:44+09:00","description":"임시 객체 생성은 성능적으로 작은 영향을 주는 부분은 아니다. 즉, 임시 객체의 기원, 그것의 비용 그리고 임시 객체를 제거할 수 있는 방법을 알지 않고서는 효율적인 코드를 작성하기 힘들다.","headline":"EFFICIENT C++_임시 객체","mainEntityOfPage":{"@type":"WebPage","@id":"https://appchemist.github.io/posts/efficient-cec9e84ec8b9c-eab09decb2b4/"},"url":"https://appchemist.github.io/posts/efficient-cec9e84ec8b9c-eab09decb2b4/"}</script><title>EFFICIENT C++_임시 객체 | Appchemist</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Appchemist"><meta name="application-name" content="Appchemist"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://avatars.githubusercontent.com/u/1546031?v=4 " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Appchemist</a></div><div class="site-subtitle font-italic">Software Developer, Want to being a Developer likes alchemist.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/appchemist" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/appchemist" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['appchemist','hotmail.co.kr'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>EFFICIENT C++_임시 객체</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>EFFICIENT C++_임시 객체</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/appchemist">appchemist</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1468626764" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2016-07-16 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2530 words"> <em>14 min</em> read</span></div></div></div><div class="post-content"><p>임시 객체 생성은 성능적으로 작은 영향을 주는 부분은 아니다. 즉, 임시 객체의 기원, 그것의 비용 그리고 임시 객체를 제거할 수 있는 방법을 알지 않고서는 효율적인 코드를 작성하기 힘들다.</p><p>임시 객체는 소스 코드에 존재하지 않고 컴파일러가 조용히 객체를 만들어 낸다. 컴파일러가 어떤 코드에서 임시 객체를 만들어 내는지 찾아내려면 숙련된 관찰력이 필요하다.</p><p>이번에는 컴파일러가 어떤 경우에 임시 객체를 생성하는지 확인해보자. <strong>객체 정의</strong></p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Rational</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="n">Rational</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span><span class="p">);</span>
<span class="nl">public:</span>
    <span class="n">Rational</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">n</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Rational"</span><span class="p">);</span> <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="n">Rational</span> <span class="nf">r1</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>			<span class="c1">// 1</span>
    <span class="n">Rational</span> <span class="n">r2</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>			<span class="c1">// 2</span>
    <span class="n">Rational</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>	<span class="c1">// 3</span>
</pre></table></code></div></div><p>컴파일러 구현과 무관하게 Rational r(100) 구문만이 임시 객체를 생성하지 않는다고 보장할 수 있다.</p><p>만약 2, 3의 형태를 사용한다면 컴파일러 구현에 따라 임시 객체를 생성할지도 모른다. 3의 형태를 사용한다고 하면  컴파일러가 이 형태를 만나면 Rational::Rational(int, int) 생성자를 사용하여 정수 100을 가지고 Rational 형식의 임시 객체를 생성한다. 그런 다음 복사 생성자를 사용해 임시 객체로부터 r3을 초기화한다.</p><p>의사 코드로 작성하면 아래와 같다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="p">{</span>    
    <span class="n">Rational</span> <span class="n">r3</span><span class="p">;</span>
    <span class="n">Rational</span> <span class="n">_temp</span><span class="p">;</span>
    <span class="n">_temp</span><span class="p">.</span><span class="n">Rational</span><span class="o">::</span><span class="n">Rational</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// Construct the temporary</span>
    <span class="n">r3</span><span class="p">.</span><span class="n">Rational</span><span class="o">::</span><span class="n">Rational</span><span class="p">(</span><span class="n">_temp</span><span class="p">);</span>       <span class="c1">// Copy-construct r3 </span>
    <span class="n">_temp</span><span class="p">.</span><span class="n">Rational</span><span class="o">::~</span><span class="n">Rational</span><span class="p">();</span>        <span class="c1">// Destroy the temporary </span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>실제로는 대부분의 컴파일러는 최적화를 통해서 임시 객체를 없애기 때문에, 3가지 형태 모두 임시 객체가 생성되지 않았다. <strong>형식 불일치</strong> 형식 불일치의 일반적인 경우에는 형식 X의 객체가 필요할 때마다 어떤 다른 형식이 제공되는 것이다. 컴파일러는 이때 제공된 형식을 형식 X의 객체로 변환한다. 이 과정에서 임시객체는 생겨난다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="p">{</span>
    <span class="n">Rational</span> <span class="n">r</span><span class="p">;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">...</span> 
<span class="p">}</span>
</pre></table></code></div></div><p>위의 Rational 클래스는 정수 매개 변수를 받는 대입 연산자를 선언하지 않았다. 기본적으로 생성되는 대입 연산자로 Rational은 우변에 Rational 객체를 기대한다. 위에서 정의한 생정자가 정수 매개 변수를 처리하는 방법을 알고 있다. 결과적으로 처리되는 순서를 의사 코드로 표현하면 아래와 같다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Rational</span> <span class="n">_temp</span><span class="p">;</span>                     <span class="c1">// Place holder for temporary</span>
<span class="n">_temp</span><span class="p">.</span><span class="n">Rational</span><span class="o">::</span><span class="n">Rational</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// Construct temporary</span>
<span class="n">r</span><span class="p">.</span><span class="n">Rational</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">_temp</span><span class="p">);</span>       <span class="c1">// Assign temporary to r</span>
<span class="n">temp</span><span class="p">.</span><span class="n">Rational</span><span class="o">::~</span><span class="n">Rational</span><span class="p">();</span>         <span class="c1">// Destroy the temporary</span>
</pre></table></code></div></div><p>위와 같이 컴파일러가 중간에 임시 객체를 생성을 하고 r객체에 해당 값을 할당한다. 이러한 부분은 프로그래밍에는 편리하지만 불필요한 객체가 생성되고 소멸되는 과정이 임의적으로 생성된 것이다. 성능 관점에서는 좋지 않다.</p><p>이런 임의의 변환을 컴파일러가 수행하지 못 하도록 제한할 수 있다. 생성자에 explicit 키워드를 사용하면 된다. 이는 개발자가 명시적으로 생성자를 사용하지 않는다면 컴파일러가 임의로 사용할 수 없도록 제한하는 것이다.</p><p>또 다른 방법으로는 operator=() 함수를 오버로드하여 이 형식의 임시 객체를 제거할 수 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Rational</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>  <span class="c1">// as before</span>
    <span class="n">Rational</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span><span class="n">m</span><span class="o">=</span><span class="n">a</span><span class="p">;</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span> 
<span class="p">};</span>
</pre></table></code></div></div><p>그리고, 해당 책에서 형식 불일치 임시 객체 생성을 해결할 수 있는 방법을 제시하고 있다. 다음 예제를 보자.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>a = b + 1.0 구문이 반복문으로 실행될 때 마다 계속해서 임시 객체가 생성된다. 즉 100회의 추가적인 임시객체가 생성된다. 이 경우 생성되는 임시객체를 제거해 보자.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">one</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">one</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>처음의 1.0 상수 값을 Complex를 one이라는 객체로 변경했고, 그로인해서 1.0이 Complex 임시 객체가 생성되는 것을 방지했다. <strong>값으로 전달</strong> 객체를 값으로 전달할 때,  다음과 같이 형식 매개변수를 실제 매개변수로 초기화 한다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="n">formalArg</span> <span class="o">=</span> <span class="n">actualArg</span><span class="p">;</span>
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="n">T</span> <span class="n">formalArg</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="n">T</span> <span class="n">t</span><span class="p">;</span>
<span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</pre></table></code></div></div><p>다음과 같이 g 함수가 존재하고 g를 위와 같이 호출을 했다. 이런 경우 컴파일러는 형식 T의 임시 객체를 생성한 다음 t를 입력 인자로 사용한다. 의사 코드로 표현하면 다음과 같다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="n">_temp</span><span class="p">;</span>
<span class="n">_temp</span><span class="p">.</span><span class="n">T</span><span class="o">::</span><span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>  <span class="c1">// copy construct _temp from t</span>
<span class="n">g</span><span class="p">(</span><span class="n">_temp</span><span class="p">);</span>       <span class="c1">// pass _temp by reference</span>
<span class="n">_temp</span><span class="p">.</span><span class="n">T</span><span class="o">::~</span><span class="n">T</span><span class="p">();</span>  <span class="c1">// Destroy _temp</span>
</pre></table></code></div></div><p>임시 객체를 생성하고 소멸하는 과정은 부담이 간다. 가능하면 객체는 포인터나 참조로 전달하여 임시 객체 생성을 방지하는 것이 좋다. <strong>값으로 반환</strong> 임시 객체가 생성될 수 있는 또 하나의 경우는 함수가 값을 반환할 때이다.</p><p>다음 예제를 통해서 확인해보자.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">string</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">...</span> <span class="c1">// Compute "s"</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">String</span> <span class="n">p</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>
</pre></table></code></div></div><p>f()의 반환 값은 string 형식의 객체이다. 결과적으로 반환 값을 저장하기 위해서 임시 객체가 생성된다. 위의 예제를 보면 f()의 반환 값은 임시 객체로 전달 되고 좌변 객체로 대입된다.  좀 더 자세한 예제로 string operator+를 가지고 확인해보자. 아래는 string operator+ 연산자의 직관적 해석으로 구현한 것이다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">string</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">lhs</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">lhs</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

    <span class="n">string</span> <span class="n">result</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">buffer</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>다음 코드는 string operator+를 사용하는 예제이다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s3</span><span class="p">;</span>

    <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span>
</pre></table></code></div></div><p>위에서 s3 = s1 + s2 구문은 아래와 같은 연산을 포함하고 있다.</p><ul><li>operator+(const string&amp;, const string&amp;); <li>string 생성자가 opertor+ 연산자내에서 string result(buffer)를 실행<li>operator+()의 반환 값을 저장하기 위해 임시 객체가 필요, 복사 생성자를 이용해서 operator+의 결과 string을 복사하여 임시 객체 생성<li>operator+() 함수가 종료하기 전에 지역 범위 객체인 result 객체가 소멸<li>대입 연산자를 사용하여 operator+가 생성한 임시 객체를 좌변 s3에 대입한다.<li>반환 값을 저장하기 위해서 사용한 임시 객체가 소멸 이렇게 s3 = s1 + s2 하나의 구문을 수행하기 위해서 6개의 연산이 수행된다. 앞에서 이야기 했던 RVO가 적용되면 result 객체를 제거하여 생성자 소멸자를 수행하지 않을 수 있다.</ul><p>그렇다면 임시 객체도 제거할 수 있을까? 임시 객체를 제거하면 두 가지의 함수 호출을 더 제거할 수 있다.</p><p>s3 = s1 + s2 구문에서 왜 임시 객체를 생성할까? 이유는 우리에게 string s3의 이전 내용을 지우고 s1 + s2의 내용으로 덮어쓸 수 있는 자유가 없기 때문이다. 대입 연산자는 string s3의 이전 내용을 새 내용으로 덮어쓰는 역활을 한다. 컴파일러는 operator=을 수행하지 않을 권한이 없기 때문에 임시 객체는 필수이다.</p><p>그렇다면 s3이 이전 내용을 가지지 않은 완전 새로운 객체라면 어떠할까? 이 경우 결과가 직접 복사 생성 되므로 임시 객체가 필요 없게 된다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="p">{</span>
    <span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span>  <span class="c1">// No temporary here.</span>
    <span class="p">...</span>
 <span class="p">}</span>
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="p">{</span>
    <span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s3</span><span class="p">;</span>
    <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span>	<span class="c1">// Temporary generated here.</span>

    <span class="p">...</span> 
<span class="p">}</span>
</pre></table></code></div></div><p>위의 형태가 임시 객체가 생성되지 않아 아래의 형태보다 좋다. <strong>op=()를 사용해 임시 객체 제거</strong></p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="p">{</span>
    <span class="n">string</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s3</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>아까 이야기 했던 방법을 이용하면 위와 같은 상황도 임시 객체를 제거할 수 있다. operator+ 대신에 operator+=를 사용하면 된다. </p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span>	<span class="c1">// Temporary generated here</span>
</pre></table></code></div></div><p>를 다음과 같이 수정하면 된다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>	<span class="c1">// operator=(). No temporary.</span>
<span class="n">s3</span> <span class="o">+=</span> <span class="n">s2</span><span class="p">;</span>	<span class="c1">// operator+=(). No temporary.</span>
</pre></table></code></div></div><p>두 코드는 논리적으로 동일하지만 전자는 임시 객체를 생성하지만 후자는 생성하지 않는다. 즉, 후자가 더 효율적인 코드이다. <strong>키 포인트</strong></p><ul><li>임시 객체는 생성자와 소멸자 실행으로 성능 부하가 생긴다.<li>생성자에 explicit 키워드를 사용하면 컴파일러가 해당 생성자를 사용해 형식 변환을 할 수 없다.<li>컴파일러는 형식 불일치를 해결하기 위해서 임시 객체를 생성<li>가능하면 객체 복사를 방지하고 참조나 포인터로 전달하고 반환하자.<li>op=연산자를 사용해 임시 객체를 제거할 수 있다. op는 +, -, *, /이 될 수 있다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >c++</a> <a href="/tags/efficient-c/" class="post-tag no-text-decoration" >Efficient C++</a> <a href="/tags/performance/" class="post-tag no-text-decoration" >Performance</a> <a href="/tags/temporary/" class="post-tag no-text-decoration" >temporary</a> <a href="/tags/temporary-object/" class="post-tag no-text-decoration" >Temporary object</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=EFFICIENT C++_임시 객체 - Appchemist&amp;url=https://appchemist.github.io/posts/efficient-cec9e84ec8b9c-eab09decb2b4/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=EFFICIENT C++_임시 객체 - Appchemist&amp;u=https://appchemist.github.io/posts/efficient-cec9e84ec8b9c-eab09decb2b4/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://appchemist.github.io/posts/efficient-cec9e84ec8b9c-eab09decb2b4/&amp;text=EFFICIENT C++_임시 객체 - Appchemist" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/DDIA-CH6/">DDIA - 파티셔닝</a><li><a href="/posts/DDIA-CH4/">DDIA - 부호화와_발전</a><li><a href="/posts/clean_architecture_ch20/">클린 아키텍처 - 업무 규칙</a><li><a href="/posts/clean_architecture_ch17/">클린 아키텍처 - 경계 선 긋기</a><li><a href="/posts/DDIA-CH1/">DDIA - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/efficient-ceba19ceab985eab3bc-eab480eba0/"><div class="card-body"> <em class="timeago small" data-ts="1468183508" > 2016-07-11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Efficient C++_로깅과 관련된 성능 이야기</h3><div class="text-muted small"><p> 소프트웨어를 유지보수를 하다보면 로깅이 매우 중요하다. 로깅을 통해서 문제 상황 추적 및 프로그램의 실행 흐름을 파악하는데 많은 도움이 된다. 이런 로깅과 관련된 코드는 성능과 관련된 여러가지 문제들을 만나기 쉽다. 로깅과 관련된 성능 최적화의 극단적인 방법은 추적 호출을 #ifdef 블록 안에 내장하여 성능 부하를 제거하는 것이다. #ifdef ...</p></div></div></a></div><div class="card"> <a href="/posts/867/"><div class="card-body"> <em class="timeago small" data-ts="1468284994" > 2016-07-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>EFFICIENT C++_생성자와 소멸자</h3><div class="text-muted small"><p> 상속 이상적으로는 생성자와 소멸자는 오버헤드를 가지지 않아야 한다. 생성자와 소멸자는 오직 필수적인 초기화와 정리 작업을 수행하며, 일반적인 컴파일러는 이것들을 인라인 함수로 만들것이다. 하지만, 상속과 합성 구현은 가끔 혹은 절대 사용되지 않는 연산을 수행하기도 한다. 상속과 합성 구현은 코드의 재사용을 위한 기술이다. 즉, 코드의 재사용과 성능과...</p></div></div></a></div><div class="card"> <a href="/posts/efficient-ceab080ec8381-ed95a8ec8898/"><div class="card-body"> <em class="timeago small" data-ts="1468331680" > 2016-07-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>EFFICIENT C++_가상 함수</h3><div class="text-muted small"><p> 동적 바인딩 덕분에 프로그래머는 형식 확인을 컴파일러에게 맡기게 되었고 많이 편해졌다. 반대로 동적 바인딩은 성능에 부정적인 영향을 끼칠 수 있다. 가상 함수 기법 만약 가상 함수를 사용하고 싶지 않다면, 직접 형식 확인 코드를 작성하여 동적 바인딩을 흉내를 낼수있다. 다음은 동물원 동물을 클래스로 표현한 것이다. class ZooAnimal {...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/efficient-cebb098ed9998eab092-ecb59ceca0/" class="btn btn-outline-primary" prompt="Older"><p>EFFICIENT C++_반환값 최적화</p></a> <a href="/posts/efficient-ceb8ba8ec9dbc-ec93b0eba088eb93/" class="btn btn-outline-primary" prompt="Newer"><p>EFFICIENT C++_단일 쓰레드 메모리 풀링</p></a></div><script src="https://utteranc.es/client.js" repo="appchemist/appchemist.github.io" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/appchemist">appchemist</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-KEPDM82EY9"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KEPDM82EY9'); }); </script>
