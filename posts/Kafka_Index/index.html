<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Kafka - 인덱스" /><meta property="og:locale" content="en" /><meta name="description" content="여기서 이야기하고자 하는 인덱스란, 카프카의 OffsetIndex, TimeIndex이다. 해당 인덱스들은 모두 파일로 관리되는데, 카프카의 로그 파일(baseoffset.log) 마다 한 벌씩 생성된다. 각각의 파일은 baseoffset.index, baseoffset.timeindex이다. 위의 baseoffset은 10자리의 숫자로 구성되며, 각 로그 파일의 시작 레코드 offset이다. 카프카의 로그 파일이 커지면 특정 레코드를 찾기 위해 로그 파일 전체를 뒤져야 하는데, 이는 효율이 떨어진다. 한 로그 파일 안에서 특정 레코드를 효율적으로 찾기 위해서 사용하는 방법이 인덱스다. 각 인덱스의 용도는 다음과 같다. OffsetIndex는 레코드의 Offset으로 로그 파일의 Position 찾기 TimeIndex는 레코드의 Timestamp로 레코드의 Offset 찾기 다음 그림을 보면 각 인덱스와 로그 파일의 대략적인 관계를 알수 있다. (출처: https://strimzi.io/blog/2021/12/17/kafka-segment-retention) 그림과 같이 인덱스를 통해서 timestamp나 레코드 offset을 기준으로 로그 파일의 position을 찾을 수 있다. 단, 인덱스 파일은 모든 레코드의 인덱스를 포함하진 않고 카프카 설정값(index.interval.bytes)을 기준으로 최소 간격을 유지하며 인덱스를 생성한다. 그래서 인덱스를 통해 찾은 position 위치 부터 로그 파일에서 찾고자 하는 Offset의 레코드를 찾는다. 인덱스와 캐시 카프카 인덱스는 기본적으로 이진탐색 알고리즘을 사용한다. 하지만 일반적인 이진탐색 알고리즘은 캐시에 적합하지 않다. 여기서 캐시는 OS의 페이지 캐시이다. 페이지 캐시와 카프카 인덱스의 특징 몇 가지만 간단히 보자. 카프카 인덱스 접근 패턴 대부분 인덱스의 마지막에서 발생 추가는 카프카는 인덱스의 끝에서 발생 검색은 대부분 카프카의 인덱스 끝 부분에서 발생 오래된 로그를 소비할 수 있지만, 시간이 지나면 최신 로그를 소비하게 됨 카프카 인덱스는 파일 Memory Mapped Files로 메모리에 사상 OS 페이지 캐시 대상 OS의 페이지 캐시 LRU 형태의 교체 알고리즘 사용 카프카 인덱스 접근 패턴은 LRU 교체 알고리즘과 잘 맞는다. 하지만 이진탐색 알고리즘은 오래된 인덱스도 조회하게 되어 문제가 발생한다. 하지만 카프카 인덱스는 이진탐색 알고리즘을 사용해 페이지 캐시 히트율을 높게 유지하며 검색을 지원한다. Warm Section 캐시에 적합한 검색의 핵심은 Warm Section이다. Warm Section은 자주 조회해서 해당 부분의 페이지가 페이지 캐시에 최대한 존재하도록 한 부분이다. 마지막 N개의 Index Entry를 의미 OS 페이지 캐시에 최대한 올라가 있도록 유도된 구간 크기는 8192 Byte로 고정 Index Entry 개수 : 8192 / ENTRY_SIZE Entry Size : 8 Byte(OffsetIndex)와 12 Byte(TimeIndex) index.interval.bytes 설정값이 커버하는 로그 범위에 영향 최소 해당 설정값 간격으로 Index Entry 생성 기본값은 4096로 4 KB 기본값일 때, 각 인덱스의 대략적인 로그 파일 커버 범위 OffsetIndex : 4 MB TimeIndex : 2.7 MB 검색 카프카는 Warm Section인 부분과 아닌 부분을 나누어 이진탐색을 수행한다. 1 2 3 4 5 6 7 8 9 10 11 int firstHotEntry = Math.max(0, entries - 1 - warmEntries()); // warm section 조회 if (compareIndexEntry(parseEntry(idx, firstHotEntry), target, searchEntity) &lt; 0) { return binarySearch(..., firstHotEntry, entries - 1); } ... // 그 외 조회 return binarySearch(..., 0, firstHotEntry); Warm Section 조회 시, indexEntry(end), indexEntry(end-N), indexEntry((end*2 -N)/2)의 페이지 조회 parseEntry(idx, entry) 코드가 파일을 메모리로 사상한 영역을 접근하여 페이지 히트 indexEntry(end-N)은 Warm Section 구분을 위해 매번 조회 indexEntry((end*2 -N)/2)은 이진탐색 시작 시 매번 접근 indexEntry(end)은 인덱스 추가 및 탐색 시 접근 대부분의 Processor의 최소 페이지 크기는 4096 byte(2018년도 기준이라 함) Warm Section은 고정 8192 Byte 크기 Warm Section 범위의 Page는 3개 이하 Warm Section 조회 시, 모든 Warm Section 구간이 페이지 케시에 올라오도록 유도됨 binarySearch는 기본적인 이진탐색 구현 결론 카프카의 인덱스 검색 연산은 Warm Section과 아닌 Section을 나누어서 이진탐색을 수행한다. 모든 삽입연산은 인덱스의 끝 부분에서 발생하고, 대부분의 검색은 Warm Section에서 발생하게 된다. 결과적으로 카프카 인덱스 파일 영역을 Memory Mapped Files를 통해서 접근하고, 8192 byte의 Warm Section으로 구분해 해당 Section이 OS 페이지 캐시를 최대한 활용하도록 설계되었다. 참고 자료 카프카 코드 https://strimzi.io/blog/2021/12/17/kafka-segment-retention" /><meta property="og:description" content="여기서 이야기하고자 하는 인덱스란, 카프카의 OffsetIndex, TimeIndex이다. 해당 인덱스들은 모두 파일로 관리되는데, 카프카의 로그 파일(baseoffset.log) 마다 한 벌씩 생성된다. 각각의 파일은 baseoffset.index, baseoffset.timeindex이다. 위의 baseoffset은 10자리의 숫자로 구성되며, 각 로그 파일의 시작 레코드 offset이다. 카프카의 로그 파일이 커지면 특정 레코드를 찾기 위해 로그 파일 전체를 뒤져야 하는데, 이는 효율이 떨어진다. 한 로그 파일 안에서 특정 레코드를 효율적으로 찾기 위해서 사용하는 방법이 인덱스다. 각 인덱스의 용도는 다음과 같다. OffsetIndex는 레코드의 Offset으로 로그 파일의 Position 찾기 TimeIndex는 레코드의 Timestamp로 레코드의 Offset 찾기 다음 그림을 보면 각 인덱스와 로그 파일의 대략적인 관계를 알수 있다. (출처: https://strimzi.io/blog/2021/12/17/kafka-segment-retention) 그림과 같이 인덱스를 통해서 timestamp나 레코드 offset을 기준으로 로그 파일의 position을 찾을 수 있다. 단, 인덱스 파일은 모든 레코드의 인덱스를 포함하진 않고 카프카 설정값(index.interval.bytes)을 기준으로 최소 간격을 유지하며 인덱스를 생성한다. 그래서 인덱스를 통해 찾은 position 위치 부터 로그 파일에서 찾고자 하는 Offset의 레코드를 찾는다. 인덱스와 캐시 카프카 인덱스는 기본적으로 이진탐색 알고리즘을 사용한다. 하지만 일반적인 이진탐색 알고리즘은 캐시에 적합하지 않다. 여기서 캐시는 OS의 페이지 캐시이다. 페이지 캐시와 카프카 인덱스의 특징 몇 가지만 간단히 보자. 카프카 인덱스 접근 패턴 대부분 인덱스의 마지막에서 발생 추가는 카프카는 인덱스의 끝에서 발생 검색은 대부분 카프카의 인덱스 끝 부분에서 발생 오래된 로그를 소비할 수 있지만, 시간이 지나면 최신 로그를 소비하게 됨 카프카 인덱스는 파일 Memory Mapped Files로 메모리에 사상 OS 페이지 캐시 대상 OS의 페이지 캐시 LRU 형태의 교체 알고리즘 사용 카프카 인덱스 접근 패턴은 LRU 교체 알고리즘과 잘 맞는다. 하지만 이진탐색 알고리즘은 오래된 인덱스도 조회하게 되어 문제가 발생한다. 하지만 카프카 인덱스는 이진탐색 알고리즘을 사용해 페이지 캐시 히트율을 높게 유지하며 검색을 지원한다. Warm Section 캐시에 적합한 검색의 핵심은 Warm Section이다. Warm Section은 자주 조회해서 해당 부분의 페이지가 페이지 캐시에 최대한 존재하도록 한 부분이다. 마지막 N개의 Index Entry를 의미 OS 페이지 캐시에 최대한 올라가 있도록 유도된 구간 크기는 8192 Byte로 고정 Index Entry 개수 : 8192 / ENTRY_SIZE Entry Size : 8 Byte(OffsetIndex)와 12 Byte(TimeIndex) index.interval.bytes 설정값이 커버하는 로그 범위에 영향 최소 해당 설정값 간격으로 Index Entry 생성 기본값은 4096로 4 KB 기본값일 때, 각 인덱스의 대략적인 로그 파일 커버 범위 OffsetIndex : 4 MB TimeIndex : 2.7 MB 검색 카프카는 Warm Section인 부분과 아닌 부분을 나누어 이진탐색을 수행한다. 1 2 3 4 5 6 7 8 9 10 11 int firstHotEntry = Math.max(0, entries - 1 - warmEntries()); // warm section 조회 if (compareIndexEntry(parseEntry(idx, firstHotEntry), target, searchEntity) &lt; 0) { return binarySearch(..., firstHotEntry, entries - 1); } ... // 그 외 조회 return binarySearch(..., 0, firstHotEntry); Warm Section 조회 시, indexEntry(end), indexEntry(end-N), indexEntry((end*2 -N)/2)의 페이지 조회 parseEntry(idx, entry) 코드가 파일을 메모리로 사상한 영역을 접근하여 페이지 히트 indexEntry(end-N)은 Warm Section 구분을 위해 매번 조회 indexEntry((end*2 -N)/2)은 이진탐색 시작 시 매번 접근 indexEntry(end)은 인덱스 추가 및 탐색 시 접근 대부분의 Processor의 최소 페이지 크기는 4096 byte(2018년도 기준이라 함) Warm Section은 고정 8192 Byte 크기 Warm Section 범위의 Page는 3개 이하 Warm Section 조회 시, 모든 Warm Section 구간이 페이지 케시에 올라오도록 유도됨 binarySearch는 기본적인 이진탐색 구현 결론 카프카의 인덱스 검색 연산은 Warm Section과 아닌 Section을 나누어서 이진탐색을 수행한다. 모든 삽입연산은 인덱스의 끝 부분에서 발생하고, 대부분의 검색은 Warm Section에서 발생하게 된다. 결과적으로 카프카 인덱스 파일 영역을 Memory Mapped Files를 통해서 접근하고, 8192 byte의 Warm Section으로 구분해 해당 Section이 OS 페이지 캐시를 최대한 활용하도록 설계되었다. 참고 자료 카프카 코드 https://strimzi.io/blog/2021/12/17/kafka-segment-retention" /><link rel="canonical" href="https://appchemist.github.io/posts/Kafka_Index/" /><meta property="og:url" content="https://appchemist.github.io/posts/Kafka_Index/" /><meta property="og:site_name" content="Appchemist" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-12-19T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Kafka - 인덱스" /><meta name="twitter:site" content="@appchemist" /><meta name="google-site-verification" content="ayKW7N1F1Lf9GFGDgfNENpw486FaeJYvFrGByBGAGEI" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-12-19T00:00:00+09:00","datePublished":"2023-12-19T00:00:00+09:00","description":"여기서 이야기하고자 하는 인덱스란, 카프카의 OffsetIndex, TimeIndex이다. 해당 인덱스들은 모두 파일로 관리되는데, 카프카의 로그 파일(baseoffset.log) 마다 한 벌씩 생성된다. 각각의 파일은 baseoffset.index, baseoffset.timeindex이다. 위의 baseoffset은 10자리의 숫자로 구성되며, 각 로그 파일의 시작 레코드 offset이다. 카프카의 로그 파일이 커지면 특정 레코드를 찾기 위해 로그 파일 전체를 뒤져야 하는데, 이는 효율이 떨어진다. 한 로그 파일 안에서 특정 레코드를 효율적으로 찾기 위해서 사용하는 방법이 인덱스다. 각 인덱스의 용도는 다음과 같다. OffsetIndex는 레코드의 Offset으로 로그 파일의 Position 찾기 TimeIndex는 레코드의 Timestamp로 레코드의 Offset 찾기 다음 그림을 보면 각 인덱스와 로그 파일의 대략적인 관계를 알수 있다. (출처: https://strimzi.io/blog/2021/12/17/kafka-segment-retention) 그림과 같이 인덱스를 통해서 timestamp나 레코드 offset을 기준으로 로그 파일의 position을 찾을 수 있다. 단, 인덱스 파일은 모든 레코드의 인덱스를 포함하진 않고 카프카 설정값(index.interval.bytes)을 기준으로 최소 간격을 유지하며 인덱스를 생성한다. 그래서 인덱스를 통해 찾은 position 위치 부터 로그 파일에서 찾고자 하는 Offset의 레코드를 찾는다. 인덱스와 캐시 카프카 인덱스는 기본적으로 이진탐색 알고리즘을 사용한다. 하지만 일반적인 이진탐색 알고리즘은 캐시에 적합하지 않다. 여기서 캐시는 OS의 페이지 캐시이다. 페이지 캐시와 카프카 인덱스의 특징 몇 가지만 간단히 보자. 카프카 인덱스 접근 패턴 대부분 인덱스의 마지막에서 발생 추가는 카프카는 인덱스의 끝에서 발생 검색은 대부분 카프카의 인덱스 끝 부분에서 발생 오래된 로그를 소비할 수 있지만, 시간이 지나면 최신 로그를 소비하게 됨 카프카 인덱스는 파일 Memory Mapped Files로 메모리에 사상 OS 페이지 캐시 대상 OS의 페이지 캐시 LRU 형태의 교체 알고리즘 사용 카프카 인덱스 접근 패턴은 LRU 교체 알고리즘과 잘 맞는다. 하지만 이진탐색 알고리즘은 오래된 인덱스도 조회하게 되어 문제가 발생한다. 하지만 카프카 인덱스는 이진탐색 알고리즘을 사용해 페이지 캐시 히트율을 높게 유지하며 검색을 지원한다. Warm Section 캐시에 적합한 검색의 핵심은 Warm Section이다. Warm Section은 자주 조회해서 해당 부분의 페이지가 페이지 캐시에 최대한 존재하도록 한 부분이다. 마지막 N개의 Index Entry를 의미 OS 페이지 캐시에 최대한 올라가 있도록 유도된 구간 크기는 8192 Byte로 고정 Index Entry 개수 : 8192 / ENTRY_SIZE Entry Size : 8 Byte(OffsetIndex)와 12 Byte(TimeIndex) index.interval.bytes 설정값이 커버하는 로그 범위에 영향 최소 해당 설정값 간격으로 Index Entry 생성 기본값은 4096로 4 KB 기본값일 때, 각 인덱스의 대략적인 로그 파일 커버 범위 OffsetIndex : 4 MB TimeIndex : 2.7 MB 검색 카프카는 Warm Section인 부분과 아닌 부분을 나누어 이진탐색을 수행한다. 1 2 3 4 5 6 7 8 9 10 11 int firstHotEntry = Math.max(0, entries - 1 - warmEntries()); // warm section 조회 if (compareIndexEntry(parseEntry(idx, firstHotEntry), target, searchEntity) &lt; 0) { return binarySearch(..., firstHotEntry, entries - 1); } ... // 그 외 조회 return binarySearch(..., 0, firstHotEntry); Warm Section 조회 시, indexEntry(end), indexEntry(end-N), indexEntry((end*2 -N)/2)의 페이지 조회 parseEntry(idx, entry) 코드가 파일을 메모리로 사상한 영역을 접근하여 페이지 히트 indexEntry(end-N)은 Warm Section 구분을 위해 매번 조회 indexEntry((end*2 -N)/2)은 이진탐색 시작 시 매번 접근 indexEntry(end)은 인덱스 추가 및 탐색 시 접근 대부분의 Processor의 최소 페이지 크기는 4096 byte(2018년도 기준이라 함) Warm Section은 고정 8192 Byte 크기 Warm Section 범위의 Page는 3개 이하 Warm Section 조회 시, 모든 Warm Section 구간이 페이지 케시에 올라오도록 유도됨 binarySearch는 기본적인 이진탐색 구현 결론 카프카의 인덱스 검색 연산은 Warm Section과 아닌 Section을 나누어서 이진탐색을 수행한다. 모든 삽입연산은 인덱스의 끝 부분에서 발생하고, 대부분의 검색은 Warm Section에서 발생하게 된다. 결과적으로 카프카 인덱스 파일 영역을 Memory Mapped Files를 통해서 접근하고, 8192 byte의 Warm Section으로 구분해 해당 Section이 OS 페이지 캐시를 최대한 활용하도록 설계되었다. 참고 자료 카프카 코드 https://strimzi.io/blog/2021/12/17/kafka-segment-retention","headline":"Kafka - 인덱스","mainEntityOfPage":{"@type":"WebPage","@id":"https://appchemist.github.io/posts/Kafka_Index/"},"url":"https://appchemist.github.io/posts/Kafka_Index/"}</script><title>Kafka - 인덱스 | Appchemist</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Appchemist"><meta name="application-name" content="Appchemist"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://avatars.githubusercontent.com/u/1546031?v=4 " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Appchemist</a></div><div class="site-subtitle font-italic">Software Developer, Want to being a Developer likes alchemist.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/appchemist" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/appchemist" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['appchemist','hotmail.co.kr'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Kafka - 인덱스</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Kafka - 인덱스</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/appchemist">appchemist</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1702911600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2023-12-19 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1306 words"> <em>7 min</em> read</span></div></div></div><div class="post-content"><p>여기서 이야기하고자 하는 인덱스란, 카프카의 OffsetIndex, TimeIndex이다.<br /> 해당 인덱스들은 모두 파일로 관리되는데, 카프카의 로그 파일(baseoffset.log) 마다 한 벌씩 생성된다.<br /> 각각의 파일은 baseoffset.index, baseoffset.timeindex이다. <br /> 위의 baseoffset은 10자리의 숫자로 구성되며, 각 로그 파일의 시작 레코드 offset이다.</p><p>카프카의 로그 파일이 커지면 특정 레코드를 찾기 위해 로그 파일 전체를 뒤져야 하는데, 이는 효율이 떨어진다.<br /> 한 로그 파일 안에서 특정 레코드를 효율적으로 찾기 위해서 사용하는 방법이 인덱스다.</p><p>각 인덱스의 용도는 다음과 같다.</p><ul><li>OffsetIndex는 레코드의 Offset으로 로그 파일의 Position 찾기<li>TimeIndex는 레코드의 Timestamp로 레코드의 Offset 찾기</ul><p>다음 그림을 보면 각 인덱스와 로그 파일의 대략적인 관계를 알수 있다.<br /> <img data-src="https://strimzi.io/assets/images/posts/2021-12-17-timeindex.png" alt="IndexAndLog" data-proofer-ignore><br /> (출처: <a href="https://strimzi.io/blog/2021/12/17/kafka-segment-retention">https://strimzi.io/blog/2021/12/17/kafka-segment-retention</a>)</p><p>그림과 같이 인덱스를 통해서 timestamp나 레코드 offset을 기준으로 로그 파일의 position을 찾을 수 있다.<br /> 단, 인덱스 파일은 모든 레코드의 인덱스를 포함하진 않고 카프카 설정값(<code class="language-plaintext highlighter-rouge">index.interval.bytes</code>)을 기준으로 최소 간격을 유지하며 인덱스를 생성한다.<br /> 그래서 인덱스를 통해 찾은 position 위치 부터 로그 파일에서 찾고자 하는 Offset의 레코드를 찾는다.</p><h1 id="인덱스와-캐시">인덱스와 캐시</h1><p>카프카 인덱스는 기본적으로 이진탐색 알고리즘을 사용한다.<br /> 하지만 일반적인 이진탐색 알고리즘은 캐시에 적합하지 않다.<br /> 여기서 캐시는 OS의 페이지 캐시이다.</p><p>페이지 캐시와 카프카 인덱스의 특징 몇 가지만 간단히 보자.</p><ul><li>카프카 인덱스 접근 패턴<ul><li>대부분 인덱스의 마지막에서 발생<li>추가는 카프카는 인덱스의 끝에서 발생<li>검색은 대부분 카프카의 인덱스 끝 부분에서 발생<ul><li>오래된 로그를 소비할 수 있지만, 시간이 지나면 최신 로그를 소비하게 됨</ul></ul><li>카프카 인덱스는 파일<ul><li>Memory Mapped Files로 메모리에 사상<li>OS 페이지 캐시 대상</ul><li>OS의 페이지 캐시<ul><li>LRU 형태의 교체 알고리즘 사용</ul></ul><p>카프카 인덱스 접근 패턴은 LRU 교체 알고리즘과 잘 맞는다.<br /> 하지만 이진탐색 알고리즘은 오래된 인덱스도 조회하게 되어 문제가 발생한다.<br /> 하지만 카프카 인덱스는 이진탐색 알고리즘을 사용해 페이지 캐시 히트율을 높게 유지하며 검색을 지원한다.</p><h1 id="warm-section">Warm Section</h1><p>캐시에 적합한 검색의 핵심은 Warm Section이다.<br /> Warm Section은 자주 조회해서 해당 부분의 페이지가 페이지 캐시에 최대한 존재하도록 한 부분이다.<br /> <img data-src="/assets/img/카프카 인덱스/Warm Section과 카프카 인덱스.png" alt="img" data-proofer-ignore></p><ul><li>마지막 N개의 Index Entry를 의미<li>OS 페이지 캐시에 최대한 올라가 있도록 유도된 구간<li>크기는 8192 Byte로 고정<ul><li>Index Entry 개수 : 8192 / ENTRY_SIZE<li>Entry Size : 8 Byte(OffsetIndex)와 12 Byte(TimeIndex)</ul><li><code class="language-plaintext highlighter-rouge">index.interval.bytes</code> 설정값이 커버하는 로그 범위에 영향<ul><li>최소 해당 설정값 간격으로 Index Entry 생성<li>기본값은 4096로 4 KB<li>기본값일 때, 각 인덱스의 대략적인 로그 파일 커버 범위<ul><li>OffsetIndex : 4 MB<li>TimeIndex : 2.7 MB</ul></ul></ul><h1 id="검색">검색</h1><p>카프카는 Warm Section인 부분과 아닌 부분을 나누어 이진탐색을 수행한다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">firstHotEntry</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">warmEntries</span><span class="o">());</span>  
  
<span class="c1">// warm section 조회  </span>
<span class="k">if</span> <span class="o">(</span><span class="n">compareIndexEntry</span><span class="o">(</span><span class="n">parseEntry</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">firstHotEntry</span><span class="o">),</span> <span class="n">target</span><span class="o">,</span> <span class="n">searchEntity</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>  
    <span class="k">return</span> <span class="nf">binarySearch</span><span class="o">(...,</span> <span class="n">firstHotEntry</span><span class="o">,</span> <span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>  
<span class="o">}</span>  
  
<span class="o">...</span>  
  
<span class="c1">// 그 외 조회  </span>
<span class="k">return</span> <span class="nf">binarySearch</span><span class="o">(...,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">firstHotEntry</span><span class="o">);</span>  
</pre></table></code></div></div><ul><li>Warm Section 조회 시, <code class="language-plaintext highlighter-rouge">indexEntry(end)</code>, <code class="language-plaintext highlighter-rouge">indexEntry(end-N)</code>, <code class="language-plaintext highlighter-rouge">indexEntry((end*2 -N)/2)</code>의 페이지 조회<ul><li><code class="language-plaintext highlighter-rouge">parseEntry(idx, entry)</code> 코드가 파일을 메모리로 사상한 영역을 접근하여 페이지 히트<li><code class="language-plaintext highlighter-rouge">indexEntry(end-N)</code>은 Warm Section 구분을 위해 매번 조회<li><code class="language-plaintext highlighter-rouge">indexEntry((end*2 -N)/2)</code>은 이진탐색 시작 시 매번 접근<li><code class="language-plaintext highlighter-rouge">indexEntry(end)</code>은 인덱스 추가 및 탐색 시 접근</ul><li>대부분의 Processor의 최소 페이지 크기는 4096 byte(2018년도 기준이라 함)<ul><li>Warm Section은 고정 8192 Byte 크기<li>Warm Section 범위의 Page는 3개 이하<li>Warm Section 조회 시, 모든 Warm Section 구간이 페이지 케시에 올라오도록 유도됨</ul><li><code class="language-plaintext highlighter-rouge">binarySearch</code>는 기본적인 이진탐색 구현</ul><h1 id="결론">결론</h1><p>카프카의 인덱스 검색 연산은 Warm Section과 아닌 Section을 나누어서 이진탐색을 수행한다.<br /> 모든 삽입연산은 인덱스의 끝 부분에서 발생하고, 대부분의 검색은 Warm Section에서 발생하게 된다.<br /> 결과적으로 카프카 인덱스 파일 영역을 Memory Mapped Files를 통해서 접근하고, 8192 byte의 Warm Section으로 구분해 해당 Section이 OS 페이지 캐시를 최대한 활용하도록 설계되었다.</p><h1 id="참고-자료">참고 자료</h1><ul><li>카프카 코드<li><a href="https://strimzi.io/blog/2021/12/17/kafka-segment-retention">https://strimzi.io/blog/2021/12/17/kafka-segment-retention</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/study/'>Study</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kafka/" class="post-tag no-text-decoration" >Kafka</a> <a href="/tags/index/" class="post-tag no-text-decoration" >Index</a> <a href="/tags/page-cache/" class="post-tag no-text-decoration" >Page_Cache</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Kafka - 인덱스 - Appchemist&amp;url=https://appchemist.github.io/posts/Kafka_Index/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Kafka - 인덱스 - Appchemist&amp;u=https://appchemist.github.io/posts/Kafka_Index/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://appchemist.github.io/posts/Kafka_Index/&amp;text=Kafka - 인덱스 - Appchemist" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/DDIA-CH6/">DDIA - 파티셔닝</a><li><a href="/posts/DDIA-CH4/">DDIA - 부호화와_발전</a><li><a href="/posts/clean_architecture_ch20/">클린 아키텍처 - 업무 규칙</a><li><a href="/posts/clean_architecture_ch17/">클린 아키텍처 - 경계 선 긋기</a><li><a href="/posts/DDIA-CH1/">DDIA - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/DDIA-CH1/"><div class="card-body"> <em class="timeago small" data-ts="1651158000" > 2022-04-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DDIA - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</h3><div class="text-muted small"><p> Table of Contents 데이터 시스템에 대한 생각 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사 신뢰성 하드웨어 결함 소프트웨어 오류 인적 오류 확장성 부...</p></div></div></a></div><div class="card"> <a href="/posts/redis-transaction/"><div class="card-body"> <em class="timeago small" data-ts="1651158000" > 2022-04-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Redis - transaction</h3><div class="text-muted small"><p> Table of Contents 사용법 Transaction에서의 Error 왜 Redis는 Roll back을 지원하지 않나? Discarding the command queued Optimistic locking using check-and-set WATCH explained Using WATCH to implement...</p></div></div></a></div><div class="card"> <a href="/posts/DDIA-CH2/"><div class="card-body"> <em class="timeago small" data-ts="1651762800" > 2022-05-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DDIA - 데이터 모델과 질의 언어</h3><div class="text-muted small"><p> Table of Contents 들어가기 관계형 모델과 문서 모델 객체 관계형 불일치 다대일과 다대다 관계 문서 데이터베이스는 역사를 반복하고 있나? 네트워크 모델 관계형 모델 문서 데이터베이스와의 비교 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/DDIA-CH6/" class="btn btn-outline-primary" prompt="Older"><p>DDIA - 파티셔닝</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div><script src="https://utteranc.es/client.js" repo="appchemist/appchemist.github.io" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/appchemist">appchemist</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-KEPDM82EY9"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KEPDM82EY9'); }); </script>
