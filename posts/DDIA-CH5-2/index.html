<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="DDIA - 복제_다중 리더와 리더 없음" /><meta property="og:locale" content="en" /><meta name="description" content="Table of Contents" /><meta property="og:description" content="Table of Contents" /><link rel="canonical" href="https://appchemist.github.io/posts/DDIA-CH5-2/" /><meta property="og:url" content="https://appchemist.github.io/posts/DDIA-CH5-2/" /><meta property="og:site_name" content="Appchemist" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-03T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="DDIA - 복제_다중 리더와 리더 없음" /><meta name="twitter:site" content="@appchemist" /><meta name="google-site-verification" content="ayKW7N1F1Lf9GFGDgfNENpw486FaeJYvFrGByBGAGEI" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-06-03T00:00:00+09:00","datePublished":"2022-06-03T00:00:00+09:00","description":"Table of Contents","headline":"DDIA - 복제_다중 리더와 리더 없음","mainEntityOfPage":{"@type":"WebPage","@id":"https://appchemist.github.io/posts/DDIA-CH5-2/"},"url":"https://appchemist.github.io/posts/DDIA-CH5-2/"}</script><title>DDIA - 복제_다중 리더와 리더 없음 | Appchemist</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Appchemist"><meta name="application-name" content="Appchemist"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://avatars.githubusercontent.com/u/1546031?v=4 " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Appchemist</a></div><div class="site-subtitle font-italic">Software Developer, Want to being a Developer likes alchemist.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/appchemist" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/appchemist" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['appchemist','hotmail.co.kr'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>DDIA - 복제_다중 리더와 리더 없음</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>DDIA - 복제_다중 리더와 리더 없음</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/appchemist">appchemist</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1654182000" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-06-03 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7313 words"> <em>40 min</em> read</span></div></div></div><div class="post-content"><h1 id="table-of-contents">Table of Contents</h1><ol><li><a href="#org99ecbb8">다중 리더 복제</a><ol><li><a href="#org299f8a2">다중 리더 복제의 사용 사례</a><ol><li><a href="#org190709f">다중 데이터센터 운영</a><li><a href="#org89e7fb8">오프라인 작업을 하는 클라이언트</a></ol><li><a href="#org3dd2c07">쓰기 충돌 다루기</a><ol><li><a href="#orgd52ac97">동기 대 비동기 충돌 감지</a><li><a href="#org75082b5">충돌 회피</a><li><a href="#orgaa56ea5">일관된 상태 수렴</a><li><a href="#org8353f89">사용자 정의 충돌 해소 로직</a><li><a href="#orgbee94c7">자동 충돌 해소</a></ol><li><a href="#org2b8b2e6">다중 리더 복제 토폴리지</a></ol><li><a href="#org3e2479e">리더 없는 복제</a><ol><li><a href="#org4dbb239">노드가 다운됐을 때 데이터베이스에 쓰기</a><ol><li><a href="#orgf7725ff">읽기 복구와 안티 엔트로피</a><li><a href="#org9aee6a5">읽기와 쓰기를 위한 정족수</a></ol><li><a href="#orgfcf0a68">정족수 일관성의 한계</a><ol><li><a href="#orgf8a5123">최신성 모니터링</a></ol><li><a href="#orgb3c0106">느슨한 정족수와 암시된 핸드오프</a><ol><li><a href="#org277c897">다중 데이터센터 운영</a></ol><li><a href="#org717c4b1">동시 쓰기 감지</a><ol><li><a href="#orgf4ae7a1">최종 쓰기 승리(동시 쓰기 버리기)</a><li><a href="#org2dc5561">“이전 발생” 관계와 동시성</a><li><a href="#org1ed2c23">이전 발생 관계 파악하기</a><li><a href="#org9c7dba9">동시에 쓴 값 병합</a><li><a href="#org35cb1b3">버전 벡터</a></ol></ol></ol><p><a id="org99ecbb8"></a></p><h1 id="다중-리더-복제">다중 리더 복제</h1><p>리더 기반 복제의 주요한 단점은 리더가 하나만 존재하고 모든 쓰기는 해당 리더를 거쳐야 한다는 것이다.<br /> 그래서 리더 기반 복제 모델은 쓰기를 허용하는 노드(리더)를 하나 이상 두는 것으로 자연스럽게 확장된다.<br /> 이 방식을 <code class="language-plaintext highlighter-rouge">다중 리더</code> (마스터 마스터, 액티브/액티브 복제) 설정이라 부른다.<br /> 이 설정에서 각 리더는 동시에 다른 리더의 팔로워 역활도 한다.</p><p><a id="org299f8a2"></a></p><h2 id="다중-리더-복제의-사용-사례"><span class="mr-2">다중 리더 복제의 사용 사례</span><a href="#다중-리더-복제의-사용-사례" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>단일 데이터센터 내에 다중 리더 설정은 복잡도에 비해 이점이 크지 않기에 적절하지 않다.<br /> 하지만 몇 가지 상황에서는 합리적인데 관련해서 알아보자.</p><p><a id="org190709f"></a></p><h3 id="다중-데이터센터-운영"><span class="mr-2">다중 데이터센터 운영</span><a href="#다중-데이터센터-운영" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>다중 리더 설정은 각 데이터센터마다 리더가 있을 수 있다.<br /> 각 데이터센터 내에는 보통의 <code class="language-plaintext highlighter-rouge">리더 팔로워 복제</code> 를 사용한다.<br /> 데이터센터 간에는 각 데이터센터의 리더가 다른 데이터센터의 리더에게 변경 사항을 복제한다.<br /> 간략화한 구성도는 아래와 같다.</p><p><img data-src="/assets/img/복제/2022-05-30_22-05-10_Multi-leader replication.jpeg" alt="img" data-proofer-ignore></p><p>단일 리더 설정 VS 다중 리더 설정 (다중 데이터 센터에서)</p><ol><li>성능<ul><li>단일 리더<br /> 모든 쓰기는 클라이언트에서 인터넷을 통해 리더가 있는 데이터센터로 이동<br /> 지연 시간 증가의 원인<li>다중 리더<br /> 모든 쓰기는 로컬 데이터센터에서 처리 -&gt; 비동기 방식으로 다른 데이터센터로 복제<br /> 사용자가 인지하는 성능이 더 좋을 수 있다.</ul><li>데이터센터 중단 내성<ul><li>단일 리더<br /> 리더의 데이터센터가 고장 나면 장애 복구를 위해 다른 데이터센터에서 한 팔로워를 리더로 승진<li>다중 리더<br /> 각 데이터센터는 서로 독립적으로 동작<br /> 고장 난 데이터센터가 온라인으로 돌아왔을 때 복제를 따라잡는다.</ul><li>네트워크 문제 내성<ul><li>단일 리더<br /> 데이터센터 간 연결의 쓰기는 동기식이기에 데이터센터 간 연결 문제에 매우 민감<li>다중 리더<br /> 데이터센터 간 연결의 쓰기를 비동기식을 사용하기에 네트워크 문제에 보다 잘 견딤.<br /> 일시적인 네트워크 중단에도 쓰기 처리는 진행되기 때문</ul></ol><p>다중 리더 복제의 큰 단점</p><ul><li>쓰기 충돌이 발생할 수 있고, 반드시 해소해야 한다.</ul><p>다중 리더 복제는 설정상의 실수나 다른 데이터베이스 기능과의 뜻밖의 상호작용이 있다.<br /> 예를 들어 자동 증가 키, 트리거, 무결성 제약은 문제가 될 소지가 많다.<br /> 이런 이유로 다중 리더 복제는 가능하면 피해야 하는 위험한 영역으로 간주되곤 한다.</p><p><a id="org89e7fb8"></a></p><h3 id="오프라인-작업을-하는-클라이언트"><span class="mr-2">오프라인 작업을 하는 클라이언트</span><a href="#오프라인-작업을-하는-클라이언트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>다중 리더 복제가 적절한 또 다른 상황은 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우이다.</p><p>이 경우 모든 디바이스(클라이언트)에는 리더처럼 동작하는 로컬 데이터베이스가 있다.</p><p>특징</p><ul><li>모든 디바이스 상에서 복제 서버 간 다중 리더 복제를 비동기 방식으로 수행하는 프로세스가 존재<li>복제 지연은 사용자가 인터넷이 가능해진 시점에 따라 몇 시간에서 몇일 이상 소요</ul><p>아키텍처 관점에서 이 설정은 근본적으로 데이터센터 간 다중 리더 복제와 동일하다.</p><p><a id="org3dd2c07"></a></p><h2 id="쓰기-충돌-다루기"><span class="mr-2">쓰기 충돌 다루기</span><a href="#쓰기-충돌-다루기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>다중 리더 복제에서 제일 큰 문제는 쓰기 충돌이 발생한다는 점이다.</p><p>쓰기 충돌에 대한 간단한 예제를 아래 그림으로 확인하자.</p><p><img data-src="/assets/img/복제/2022-05-31_08-47-30_write-conflict-simple-example.jpeg" alt="img" data-proofer-ignore></p><p><a id="orgd52ac97"></a></p><h3 id="동기-대-비동기-충돌-감지"><span class="mr-2">동기 대 비동기 충돌 감지</span><a href="#동기-대-비동기-충돌-감지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>다중 리더 설정은 복제를 비동기식으로 동작한다고 했다.</p><p>비동기 충돌 감지</p><ul><li>동시에 발생한 쓰기는 모두 성공<li>충돌은 이후 특정 시점에서 비동기로만 감지<li>이 시점에 사용자에게 충돌 해소 요청은 너무 늦을 수도 있다.</ul><p>동기 충돌 감지</p><ul><li>이론적으로 가능<li>다중 리더 복제의 주요 장점을 상실<br /> 각 복제 서버가 독립적으로 쓰기를 허용<li>단일 리더 복제를 사용하는 편이 좋음<br /> 다중 리더 복제의 주요 장점을 상실하기 때문</ul><p><a id="org75082b5"></a></p><h3 id="충돌-회피"><span class="mr-2">충돌 회피</span><a href="#충돌-회피" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>충돌을 처리하는 제일 간단한 전략<br /> 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않는다란 개념이다.</p><p><strong>한 가지 예</strong><br /> 특정 사용자의 요청을 동일한 데이터센터로 항상 라우팅한다.<br /> 그래서 해당 데이터센터 내 리더를 사용해 읽기와 쓰기를 하게끔 보장하는 것이다.<br /> 한 사용자 관점에서 보면 구성은 기본적으로 단일 리더이다.</p><p>하지만 여러가지 이유(특정 데이터센터 장애 등)로 지정된 리더를 변경하고 싶을 수도 있다.<br /> 이런 상황에서 충돌 회피가 실패한다.<br /> 그러면 <strong>다른 리더에서 동시 기록 가능성을 대처</strong> 해야 한다.</p><p><a id="orgaa56ea5"></a></p><h3 id="일관된-상태-수렴"><span class="mr-2">일관된 상태 수렴</span><a href="#일관된-상태-수렴" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>다중 리더 설정에서는 <strong>쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확</strong> 하지 않다.<br /> 어떤 순서도 다른 순서보다 “더 정확”하지 않다.<br /> 이런 순서와 관련된 내용은 <code class="language-plaintext highlighter-rouge">"이전 발생" 관계와 동시성</code> 에서 살펴본다.</p><p>단순하게 각 복제 서버가 쓰기를 본 순서대로 적용한다면 데이터베이스는 결국 일관성 없는 상태가 된다.</p><p>모든 복제 계획은 모든 복제 서버가 최종적으로 동일하다는 사실을 보장해야 한다.<br /> 따라서 데이터베이스는 <strong>수렴</strong> (convergent) 방식으로 충돌을 해소해야 한다.<br /> <code class="language-plaintext highlighter-rouge">수렴 방식</code> : 모든 변경이 복제돼 모든 서버에 동일한 최종 값이 전달되게 해야 한다</p><p>수렴 충돌 해소를 달성하는 방법</p><ul><li>각 쓰기에 고유 ID를 부여, 가장 높은 ID를 가진 쓰기를 선택<br /> 가장 높은 ID(winner)를 선택하고, 다른 쓰기는 버린다.<br /> TimeStamp를 사용하면 최종 쓰기 승리(last write wins, LWW)라 부른다.<br /> 대중적이지만 데이터 유실 위험이 존재<li>각 복제 서버에 고유 ID를 부여, 가장 높은 ID의 복제 서버에서 생긴 쓰기를 우선 적용<br /> 위와 유사하지만 대상이 복제 서버이고 위는 각 쓰기<br /> 데이터 유실 위험 존재<li>어떻게든 값을 병합<li>명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존<br /> 충돌을 해소하는 애플리케이션 코드가 필요</ul><p><a id="org8353f89"></a></p><h3 id="사용자-정의-충돌-해소-로직"><span class="mr-2">사용자 정의 충돌 해소 로직</span><a href="#사용자-정의-충돌-해소-로직" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다르다.<br /> 따라서 대부분의 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직을 수행한다.</p><p>사용자 정의 충돌 해소 로직은 쓰기나 읽기 수행 중 실행될 수 있다.</p><ol><li>쓰기 수행 중<br /> 복제된 변경 사항 로그에서 데이터베이스 시스템이 충돌을 감지하자마자 충돌 핸들러를 호출<br /> 백그라운드 프로세스에서 빠르게 실행돼야 함<li>읽기 수행 중<br /> 충돌을 감지하면 모든 충돌 쓰기를 저장<br /> 데이터를 읽을 때 여러 버전의 데이터를 에플리케이션에 반환<br /> 그리고 애플리케이션은 사용자에게 충돌 내용을 보여주거나 자동으로 충돌을 해소 후 결과를 데이터베이스에 기록</ol><p><strong>충돌 해소는 보통 전체 트랜잭션이 아니라 개별 로우나 문서 수준에서 적용된다.</strong></p><p><a id="orgbee94c7"></a></p><h3 id="자동-충돌-해소"><span class="mr-2">자동 충돌 해소</span><a href="#자동-충돌-해소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li>충돌 없는 복제 데이터타입(Conflict-free replicated datatype, CRDT)<br /> 셋, 맵, 정렬 목록, 카운터 등을 위한 데이터 구조의 집합으로 동시에 여러 사용자가 편집할 수 있고 합리적인 방법으로 충돌을 자동 해소<br /> 이중 병합(two-way merge) 사용<br /> 리악 2.0에서 일부 구현<br /> <a href="https://channel.io/ko/blog/crdt_vs_ot">CRDT vs OT 참고</a><li>병합 가능한 영속 데이터 구조(mergeable persistent data structure)<br /> 깃 버전 제어 시스템과 유사하게 명시적으로 히스토리를 추적하고 삼중 병합 함수(three-way merge function)를 사용<li>운영 변환(operational transformation)<br /> 협업 편집 애플리케이션의 충돌 해소 알고리즘<br /> <a href="https://channel.io/ko/blog/crdt_vs_ot">CRDT vs OT 참고</a></ol><p><a id="org2b8b2e6"></a></p><h2 id="다중-리더-복제-토폴리지"><span class="mr-2">다중 리더 복제 토폴리지</span><a href="#다중-리더-복제-토폴리지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>복제 토폴로지 : 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명</p><p><img data-src="/assets/img/복제/2022-06-02_20-31-02_replication-topology.jpeg" alt="img" data-proofer-ignore></p><p>원형 토폴로지(Circular topology)와 별 모양 토폴로지(Star topology)</p><ul><li>모든 복제 서버에 도달하기 전에 여러 노드를 거쳐야 함<li>무한 복제 로프를 방지하기 위한 각 노드 별 고유 식별자 사용<br /> 복제 로그에서 각 쓰기는 지나온 모든 노드의 식별자가 태깅<br /> 자신의 식별자가 태깅된 경우, 데이터 변경 사항을 무시<li>하나의 노드에 장애가 발생하면 다른 노드 간 복제 메시지 흐름에 방해를 줌<br /> 장애 노드를 회피하게끔 재설정 가능하지만 보통 수동으로 수행해야 함</ul><p>전체 연결 토폴로지(All-to-all topology)</p><ul><li>가장 일반적인 토폴로지<li>빽빽하게 연결되어 내결함성이 더 좋음<li>네트워크 연결 간 속도 차이로 일부 복제 메시지가 다른 메시지를 “추월”할 수 있음</ul><p><a id="org3e2479e"></a></p><h1 id="리더-없는-복제">리더 없는 복제</h1><p>모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식이다.</p><p>리더 없는 복제는 아마존이 내부 다이나모(Dynamo) 시스템에서 사용한 후 다시 유행했다.<br /> 다이나모에서 영감을 얻은 리더 없는 복제 모델의 오픈 소스 데이터스토어를 <code class="language-plaintext highlighter-rouge">다이나모 스타일</code> 이라 하며, 리악, 카산드라, 볼드모트가 존재한다.</p><p>전송 방식</p><ul><li>클라이언트가 여러 복제 서버에 직접 전송 방식<li>코디네이터 노드가 중간에서 복제 서버에 전송하는 방식<br /> 특정 순서로 쓰기를 수행하지는 않음</ul><p><a id="org4dbb239"></a></p><h2 id="노드가-다운됐을-때-데이터베이스에-쓰기"><span class="mr-2">노드가 다운됐을 때 데이터베이스에 쓰기</span><a href="#노드가-다운됐을-때-데이터베이스에-쓰기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>여러 복제 서버 중 하나를 사용할 수 없어도 장애 복구가 필요하지 않다.</p><p><img data-src="/assets/img/복제/2022-06-02_21-37-29_quorum-write_read-repair.jpeg" alt="img" data-proofer-ignore></p><p>복제 서버 3이 다운된 동안 발생한 모든 쓰기는 해당 노드에서 누락됐다.<br /> 결과적으로 클라이언트가 복제 서버 3에서 데이터를 읽는다면 오래된(outdated) 값을 얻을 수 있다.</p><p>이 문제를 해결하기 위해서 <strong>읽기 요청을 병렬로 여러 노드에 전송</strong> 한다.<br /> 이때 받은 여러 요청의 결과 중 버전 숫자를 사용해서 어떤 값이 최신 내용인지 결정한다.</p><p><a id="orgf7725ff"></a></p><h3 id="읽기-복구와-안티-엔트로피"><span class="mr-2">읽기 복구와 안티 엔트로피</span><a href="#읽기-복구와-안티-엔트로피" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>위의 그림에서 복제서버 3이 누락된 쓰기를 따라잡는 방법이 여러가지 있다.<br /> 그 중 두 가지 메커니즘이 주로 사용된다.</p><ol><li>읽기 복구<br /> 클라이언트는 복제 서버 3의 값이 오래된 값이라는 사실을 버전 값을 사용해 알게 된다.<br /> 그리고 클라이언트는 해당 복제 서버에 새로운 값을 다시 기록한다.<li>안티 엔트로피 처리<br /> 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복제한다.<br /> 특정 순서로 쓰기를 복사하기 때문에 데이터가 복사되기까지 상당한 지연이 있을 수 있다.</ol><p><a id="org9aee6a5"></a></p><h3 id="읽기와-쓰기를-위한-정족수"><span class="mr-2">읽기와 쓰기를 위한 정족수</span><a href="#읽기와-쓰기를-위한-정족수" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>정족수란 몇 개의 서버로 부터 읽기 요청과 쓰기 요청을 어느 범위까지 허용할지에 대한 내용이다.</p><p>일반화해서 보자면 아래와 같다.<br /> n : 복제 서버(클러스터에 n개 이상의 노드가 있을 수 있음)<br /> w : 모든 쓰기는 최소 w개의 노드에서 성공<br /> r : 모든 읽기는 최소 r개의 노드에서 질의<br /> w + r &gt; n이면 읽을 때 최신 값을 얻은 것으로 기대한다.</p><p>다이나모 스타일 데이터베이스에서는 n, w, r 파라미터는 대개 설정 가능하다.</p><p><a id="orgfcf0a68"></a></p><h2 id="정족수-일관성의-한계"><span class="mr-2">정족수 일관성의 한계</span><a href="#정족수-일관성의-한계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>w + r &gt; n인 경우에 오래된 값을 반환하는 에지 케이스가 존재한다.</p><ul><li>느슨한 정족수를 사용한다면 w개의 쓰기는 r개의 읽기와 다른 노드에서 수행될 수 있다.<br /> r개의 노드와 w개의 노드가 겹치는 것을 보장하지 않음<br /> 느슨한 정족수 : 정족수를 만족하지 않더라도 쓰기를 받아들이고 홈 노드에 속하지 않지만 연결할 수 있는 노드로써 기록<li>두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않음<br /> 해결책으로 동시 쓰기를 합치는 방법(“쓰기 충돌 다루기” 참고)<br /> 승자를 타임스탬프 기반으로 결정한다면 시계 스큐(clock skew)로 인해 쓰기가 유실될 수 있음<li>쓰기가 읽기와 동시에 발생하면 읽기가 최신 값을 반환하는지 불분명<br /> 쓰기가 일부 복제 서버에만 반영될 수 있기 때문<li>쓰기가 w보다 적은 서버에서 성공하더라도 성공한 복제 서버에서는 롤백하지 않음<br /> 이어지는 읽기에 해당 쓰기 값이 반환될 수도 있고 아닐 수도 있다.<li>새 값을 가진 노드가 고장나면, 이전 값을 가진 노드가 이전 값을 전파하여 복원되는 경우<br /> 새로운 값을 저장한 복제 서버 수가 w보다 낮아져 정족수 조건이 깨질 수 있음<li>모든 과정이 올바르게 동작해도 시점 문제로 에지 케이스가 존재할 수 있음</ul><p>즉, 매개변수 w와 r로 오래된 값을 읽는 확률을 조정할 수 있지만 절대적으로 보장할 수는 없다.<br /> “복제 지연 문제”에서 설명한 보장을 대개 받을 수 없기에 관련된 이상 현상이 발생할 수 있다.</p><p>견고한 보장은 일반적으로 트랜잭션이나 합의가 필요하다.</p><p><a id="orgf8a5123"></a></p><h3 id="최신성-모니터링"><span class="mr-2">최신성 모니터링</span><a href="#최신성-모니터링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>운영 관점에서 데이터베이스가 최신 결과를 반환하는지 여부를 모니터링하는 일은 중요하다.</p><p>복제 형식에 따른 분류</p><ol><li>리더 기반 복제<br /> 데이터베이스는 일반적으로 복제 지연에 대한 지표를 노출하며 이 지표는 모니터링 시스템에 제공된다.<br /> 현재 위치에서 팔로워의 현재 위치를 빼면 복제 지연량을 측정할 수 있다.<li>리더 없는 복제<br /> 쓰기가 적용된 순서를 고정할 수 없어서 모니터링이 조금 더 어려움<br /> 데이터베이스가 읽기 복구만 사용한다면 자주 읽히지 않는 값이 얼마나 오래된 것인지에 대한 제한이 없다.</ol><p>최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 “최종적”을 정량화할 수 있어야 한다.</p><p><a id="orgb3c0106"></a></p><h2 id="느슨한-정족수와-암시된-핸드오프"><span class="mr-2">느슨한 정족수와 암시된 핸드오프</span><a href="#느슨한-정족수와-암시된-핸드오프" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>적절히 설정된 정족수가 있는 데이터베이스는 장애 복구 없이 개별 노드 장애를 용인한다.<br /> 요청은 w나 r개 노드가 응답할 때 반환할 수 있어 개별 노드의 응답이 느려지는 것도 허용 가능하다.</p><p>리더 없는 복제가 매력적인 경우</p><ul><li>높은 가용성과 낮은 지연 시간이 필요한 경우<li>오래된 값 읽기를 허용하는 경우</ul><p>노드가 n개 이상인 대규모 클러스터에서 클라이언트는 네트워크 장애 상황에서 정족수 구성에 들어가지 않는 데이터베이스 노드에 연결될 가능성이 있다.<br /> 이 경우 데이터베이스 설계자는 트레이드오프에 직면한다.</p><ol><li>w나 r 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환<li>일단 쓰기를 받아들이고 값이 보통 저장되는 “홈” 노드에 속하지 않지만 연결할 수 있는 노드에 기록</ol><p>2번을 <code class="language-plaintext highlighter-rouge">느슨한 정족수</code> 라고 한다.<br /> 쓰기와 읽기는 여전히 w와 r의 성공 응답이 필요하지만 값을 위해 지정된 n개의 “홈” 노드에 없는 노드가 포함될 수 있다.</p><p>네트워크 장애 상황이 해제 되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 “홈” 노드로 전송한다.<br /> 이것을 <code class="language-plaintext highlighter-rouge">암시적 핸드오프</code> 라고 한다.</p><p>느슨한 정족수는 쓰기 가용성 및 지속성을 높이는 데 특히 유용하다.<br /> 이는 모든 일반적인 다이나모 구현에서 선택 사항이다.</p><p><a id="org277c897"></a></p><h3 id="다중-데이터센터-운영-1"><span class="mr-2">다중 데이터센터 운영</span><a href="#다중-데이터센터-운영-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>리더 없는 복제도 동시 쓰기 충돌, 네트워크 중단, 지연 시간 급증을 허용하기에 다중 데이터센터 운영에 적합하다.</p><p>카산드라와 볼드모트는 일반적인 리더 없는 모델에 다중 데이터센터 지원을 구현했다.</p><ul><li>n개의 복제 서버 수에는 모든 데이터센터의 노드가 포함<li>각 데이터센터마다 n개의 복제 서버 중 몇 개를 보유할지를 지정<li>클라이언트의 각 쓰기는 데이터센터 상관없이 모든 복제 서버에 전송<li>데이터센터 간 연결의 지연과 중단에 영향을 받지 않음<br /> 클라이언트는 보통 로컬 데이터센터 안에서 정족수 노드의 확인 응답을 기다리기 때문<br /> 보통 쓰기는 비동기로 처리</ul><p>리악의 경우</p><ul><li>n은 하나의 데이터센터 안에 있는 복제 서버 수<li>데이터센터 간 복제는 백그라운드에서 비동기<br /> 방식은 다중 리더 복제와 유사</ul><p><a id="org717c4b1"></a></p><h2 id="동시-쓰기-감지"><span class="mr-2">동시 쓰기 감지</span><a href="#동시-쓰기-감지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>다이나모 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용한다.<br /> 그래서 엄격한 정족수를 사용하더라도 충돌이 발생한다.<br /> 이런 상황은 다중 리더 복제의 “쓰기 충돌 다루기”와 유사하다.<br /> 또한 읽기 복구나 암시된 핸드오프 중에도 발생할 수 있다.</p><p><strong>문제는 이벤트가 다른 노드에 다른 순서로 도착할 수 있다는 것</strong> 이다.<br /> 이는 다양한 네트워크 지연과 부분적인 장애 때문이다.</p><p>다른 순서로 쓰기 이벤트가 도착하거나 순간적인 노드 장애로 인해 노드간의 데이터가 서로 달라진 상황을 아래 그림에서 확인할 수 있다.</p><p><img data-src="/assets/img/복제/2022-06-03_19-42-24_concurrent-writes.jpeg" alt="img" data-proofer-ignore></p><p>최종적인 일관성을 달성하기 위해 애플리케이션 개발자는 데이터베이스 내부에서 충돌을 어떻게 다루는지 잘 알아야 한다.</p><p><a id="orgf4ae7a1"></a></p><h3 id="최종-쓰기-승리동시-쓰기-버리기"><span class="mr-2">최종 쓰기 승리(동시 쓰기 버리기)</span><a href="#최종-쓰기-승리동시-쓰기-버리기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>“예전” 값을 버리고 가장 “최신” 값으로 덮어쓰는 방법이다.<br /> 어떤 쓰기가 “최신”인지 명확하게 결정할 수 있는 한 모든 쓰기는 최종적으로 모든 복제 서버에 복사되므로 복제본은 최종적으로 동일한 값으로 수렴한다.</p><p>여기에서 “최신”은 확실하게 구분하기 힘든 경우가 많다.<br /> 이렇게 “최신”이 확실하지 않다면 이벤트의 순서를 정할 수 없기에 <code class="language-plaintext highlighter-rouge">동시</code> 쓰기라 해야 한다.</p><p>비록 쓰기는 자연적인 순서가 없지만 임의로 순서를 정할 수 있다.<br /> 예를 들어 쓰기에 타임스탬프를 붙여서 최종 쓰기 승리(LWW)라 부르는 충돌 해소 알고리즘을 사용할 수도 있다.</p><p>LWW는 최종적 수렴 달성이 목표이지만 지속성을 희생한다.<br /> 결국 여러 쓰기 중 최신의 쓰기가 남고 그외의 쓰기는 버리기 때문이다.<br /> 손실 데이터를 허용하지 않는다면 LWW는 충돌 해소에 적합하지 않다.<br /> 보통 캐싱과 같이 손실된 쓰기를 허용하는 경우가 있다.</p><p>LWW로 데이터베이스를 안전하게 사용하는 유일한 방법은 <strong>키를 한번</strong> 만 사용하는 것이다.(이후 불변)<br /> 이 방법은 같은 키를 동시에 갱신하는 상황을 방지한다.</p><p><a id="org2dc5561"></a></p><h3 id="이전-발생-관계와-동시성"><span class="mr-2">“이전 발생” 관계와 동시성</span><a href="#이전-발생-관계와-동시성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>두 가지 작업이 동시에 수행됐는지 여부에 대해 어떻게 결정되는지 알아보자.</p><p>몇 가지 예를 살펴보자.</p><ol><li>두 개의 쓰기에 순서가 존재하는 경우(클라이언트 시점)<br /> A(1 입력) -&gt; B(A++)인 경우<br /> B는 A에 인과성이 있다.(causally dependent)<li>두 개의 쓰기가 동시에 수행된 경우(클라이언트 시점)<br /> 각 클라이언트가 작업을 시작할 때 다른 클라이언트가 동일한 키에 대한 작업을 수행했는지 알지 못한다.<br /> 따라서 작업 간에 인과성이 없다.</ol><p>작업 A가 다른 작업 B 보다 이전 발생(happens-before)라고 말하는 경우는 아래와 같다.</p><ul><li>작업 B가 작업 A에 대해서 아는 경우<li>작업 B가 작업 A에 의존 하는 경우<li>작업 B가 작업 A를 기반으로 작업 하는 경우</ul><p>즉, 한 작업이 다른 작업 이전에 발생했는지가 동시성을 의미를 정의하는 핵심이다.<br /> 한 작업이 다른 작업보다 먼저 발생(happens-before)하지 않으면 단순히 <strong>동시 작업</strong> 이라 말한다.</p><p>두 작업이 동시성인지 아닌지 알 수 있는 알고리즘이 필요하다.<br /> 한 작업이 다른 작업 전에 발생했다면 나중 작업은 이전 작업을 덮어쓸 수 있다.<br /> 하지만 작업이 동시에 발생하면 충돌을 해소해야 한다.</p><p><a id="org1ed2c23"></a></p><h3 id="이전-발생-관계-파악하기"><span class="mr-2">이전 발생 관계 파악하기</span><a href="#이전-발생-관계-파악하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>두 작업이 동시성인지 아닌지 여부를 결정하는 알고리즘을 살펴보자.<br /> 여기서는 상황을 단순하게 만들기 위해 하나의 복제본을 가진 데이터베이스에서 시작한다.</p><p><img data-src="/assets/img/복제/2022-06-03_22-59-49_capturing-causal-dependencies.jpeg" alt="img" data-proofer-ignore></p><p>위의 그림의 작업 간 데이터플로를 아래에서 도표로 보여준다.<br /> 화살표는 어떤 작업이 다른 작업 이전에 발생했는지와 나중 작업이 이전 작업에 수행된 작업을 알거나 의존했다는 사실이다.</p><p><img data-src="/assets/img/복제/2022-06-03_23-03-26_graph-causal-dependencies.jpeg" alt="img" data-proofer-ignore></p><p>서버는 버전 번호를 보고 두 작업이 동시에 수행됐는지 여부를 결정할 수 있다.<br /> 값 자체가 데이터 구조인 셈이다.<br /> 해당 알고리즘은 다음과 같이 동작한다.</p><ul><li>서버가 모든 키에 대한 버전 번호를 유지, 키를 기록할 때마다 버전 번호를 증가<li>클라이언트가 키를 읽을 때 서버는 최신 버전과 덮어쓰지 않은 모든 값을 반환<br /> 클라이언트는 쓰기 전에 키를 읽어야 한다.<li>클라이언트가 키를 기록할 때 이전 읽기 버전 번호를 포함<br /> 또한 이전 읽기에서 받은 모든 값을 합쳐야 한다.<li>서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있다.<br /> 하지만 높은 버전 번호의 모든 값은 유지</ul><p><a id="org9c7dba9"></a></p><h3 id="동시에-쓴-값-병합"><span class="mr-2">동시에 쓴 값 병합</span><a href="#동시에-쓴-값-병합" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>해당 알고리즘은 어떤 데이터도 자동으로 삭제되지 않음을 보장한다.<br /> 하지만 클라이언트가 추가적으로 작업을 해줘야 한다.<br /> 여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야 한다.<br /> 리악은 이런 동시 값을 <strong>형제(sibling)</strong> 값이라 한다.</p><p>형제 값 병합은 다중 리더 복제에서 충돌을 해소하는 문제와 본질적으로 같다.</p><p>위의 장바구니 예제에서 형제를 병합하는 합리적인 접근 방식은 합집합을 취하는 것이다.<br /> 하지만 상품을 제거도 할 수 있게 하려면 합집합으로는 올바른 결과를 얻을 수 없다.<br /> 단순히 삭제하는 것으로는 상품을 제거할 수 없다.<br /> 제거된 상품이 다시 나타날 수 있다.<br /> 이를 위해서 <strong>툼스톤</strong> 이라는 방법을 사용한다.<br /> 형제를 병합할 때, 상품이 제거됐음을 나타내는 표시를 해당 버전에 남기는 것이다.</p><p>애플리케이션 코드에서 형제 병합은 복잡하고 오류가 발생하기 쉽다.<br /> 이런 것을 자동으로 수행하기 위한 몇 가지 노력이 있다.<br /> 예를 들어서 리악은 CRDT라는 방법을 사용한다.</p><p><a id="org35cb1b3"></a></p><h3 id="버전-벡터"><span class="mr-2">버전 벡터</span><a href="#버전-벡터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>장바구니 예제는 단일 복제본을 사용했다.<br /> 다중 복제본인 경우 살펴보자.</p><p>장바구니 예제는 의존성 파악을 위해 단일 버전을 사용했다.<br /> 다중 복제본인 경우 <strong>키당 버전 번호</strong> 뿐만 아니라 <strong>복제본당 버전 번호</strong> 도 사용해야 한다.</p><p>모든 복제본의 버전 번호 모음을 <strong>버전 벡터(version vector)</strong> 라고 부른다.<br /> 이를 변경한 몇 가지 방법 중 <strong>도티드 버전 벡터(dotted version vector)</strong> 란 것도 있다.</p><p>버전 벡터를 사용하면 데이터베이스는 덮어쓰기와 동시 쓰기를 구분할 수 있다.<br /> 참고 : <a href="https://martinfowler.com/articles/patterns-of-distributed-systems/version-vector.html">version vector</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/study/'>Study</a>, <a href='/categories/book/'>Book</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/data/" class="post-tag no-text-decoration" >Data</a> <a href="/tags/applicationn/" class="post-tag no-text-decoration" >Applicationn</a> <a href="/tags/system/" class="post-tag no-text-decoration" >System</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=DDIA - 복제_다중 리더와 리더 없음 - Appchemist&amp;url=https://appchemist.github.io/posts/DDIA-CH5-2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=DDIA - 복제_다중 리더와 리더 없음 - Appchemist&amp;u=https://appchemist.github.io/posts/DDIA-CH5-2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://appchemist.github.io/posts/DDIA-CH5-2/&amp;text=DDIA - 복제_다중 리더와 리더 없음 - Appchemist" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/DDIA-CH6/">DDIA - 파티셔닝</a><li><a href="/posts/DDIA-CH4/">DDIA - 부호화와_발전</a><li><a href="/posts/clean_architecture_ch20/">클린 아키텍처 - 업무 규칙</a><li><a href="/posts/clean_architecture_ch17/">클린 아키텍처 - 경계 선 긋기</a><li><a href="/posts/DDIA-CH1/">DDIA - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/DDIA-CH1/"><div class="card-body"> <em class="timeago small" data-ts="1651158000" > 2022-04-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DDIA - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</h3><div class="text-muted small"><p> Table of Contents 데이터 시스템에 대한 생각 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사 신뢰성 하드웨어 결함 소프트웨어 오류 인적 오류 확장성 부...</p></div></div></a></div><div class="card"> <a href="/posts/DDIA-CH2/"><div class="card-body"> <em class="timeago small" data-ts="1651762800" > 2022-05-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DDIA - 데이터 모델과 질의 언어</h3><div class="text-muted small"><p> Table of Contents 들어가기 관계형 모델과 문서 모델 객체 관계형 불일치 다대일과 다대다 관계 문서 데이터베이스는 역사를 반복하고 있나? 네트워크 모델 관계형 모델 문서 데이터베이스와의 비교 ...</p></div></div></a></div><div class="card"> <a href="/posts/DDIA-CH3/"><div class="card-body"> <em class="timeago small" data-ts="1652367600" > 2022-05-13 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DDIA - 저장소와 검색</h3><div class="text-muted small"><p> Table of Contents 들어가기 데이터베이스를 강력하게 만드는 데이터 구조 해시 색인 SS테이블과 LSM 트리 SS테이블 생성과 유지 성능 최적화 모아보기 B 트리 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/DDIA-CH5-1/" class="btn btn-outline-primary" prompt="Older"><p>DDIA - 복제_단일 리더</p></a> <a href="/posts/DDIA-CH6/" class="btn btn-outline-primary" prompt="Newer"><p>DDIA - 파티셔닝</p></a></div><script src="https://utteranc.es/client.js" repo="appchemist/appchemist.github.io" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/appchemist">appchemist</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/clean-architecture/">clean architecture</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/orm/">ORM</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/applicationn/">Applicationn</a> <a class="post-tag" href="/tags/data/">Data</a> <a class="post-tag" href="/tags/system/">System</a> <a class="post-tag" href="/tags/efficient-c/">Efficient C++</a> <a class="post-tag" href="/tags/performance/">Performance</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-KEPDM82EY9"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KEPDM82EY9'); }); </script>
